<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MWAL ‚Äî App Unique (Wallet + Caisse + Blockchain GUN)</title>
<script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
<style>
:root{--bg:#070a10;--card:#0b1220;--line:rgba(255,255,255,.14);--ink:#e5e7eb;--mut:rgba(229,231,235,.72);--acc:#6ee7ff;--ok:#34d399;--warn:#f59e0b;}
*{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
body{margin:0;background:radial-gradient(1100px 900px at 10% -20%, rgba(110,231,255,.18), transparent 55%),
                 radial-gradient(900px 800px at 90% 0%, rgba(98,246,181,.14), transparent 60%),
                 var(--bg);color:var(--ink);}
header{position:sticky;top:0;z-index:10;backdrop-filter: blur(10px);
        background:rgba(7,10,16,.72);border-bottom:1px solid var(--line);}
.bar{max-width:1280px;margin:0 auto;padding:12px 14px;display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
.brand b{font-size:14px;letter-spacing:.2px}
.brand span{font-size:12px;color:var(--mut)}
.tabs{display:flex;gap:8px;flex-wrap:wrap}
.tab{cursor:pointer;border:1px solid var(--line);background:rgba(0,0,0,.18);color:var(--ink);
      padding:8px 12px;border-radius:999px;font-weight:650;font-size:12px}
.tab[aria-selected="true"]{outline:2px solid rgba(110,231,255,.45)}
main{max-width:1280px;margin:0 auto;padding:14px}
.view{display:none}
.view.active{display:block}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
.card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
      border:1px solid var(--line);border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.45);padding:14px}
.k{font-size:12px;color:var(--mut);margin-bottom:6px}
.v{font-size:28px;font-weight:900;letter-spacing:.2px}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
input,select{padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:rgba(0,0,0,.18);color:var(--ink);outline:none}
button{cursor:pointer;border:1px solid var(--line);background:rgba(110,231,255,.10);color:var(--ink);
        padding:10px 12px;border-radius:12px;font-weight:650}
button:hover{background:rgba(110,231,255,.16)}
.pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid var(--line);
       background:rgba(0,0,0,.18);font-size:12px;color:var(--mut)}
.dot{width:8px;height:8px;border-radius:99px;background:var(--warn)}
.dot.ok{background:var(--ok)}
iframe{width:100%;height:calc(100vh - 86px);border:1px solid var(--line);border-radius:18px;background:rgba(0,0,0,.12)}
.small{font-size:12px;color:var(--mut);line-height:1.4}
canvas{width:100%;height:220px;border:1px solid var(--line);border-radius:14px;background:rgba(0,0,0,.15)}
</style>
</head>
<body>
<header>
  <div class="bar">
    <div class="brand">
      <b>MWAL ‚Äî App Unique</b>
      <span>Wallet (MWOLLOWM t√©moin) + Caisse (MWAL minute) ‚Üí D√©p√¥ts automatiques ‚Üí Blockchain commune ‚Üí Cours public Gun/Render</span>
    </div>
    <div class="tabs" role="tablist" aria-label="Navigation">
      <button class="tab" id="tDash" role="tab" aria-controls="vDash" aria-selected="true">Dashboard</button>
      <button class="tab" id="tWallet" role="tab" aria-controls="vWallet" aria-selected="false">Wallet</button>
      <button class="tab" id="tCaisse" role="tab" aria-controls="vCaisse" aria-selected="false">Caisse</button>
      <button class="tab" id="tExpert" role="tab" aria-controls="vExpert" aria-selected="false">‚öôÔ∏è Blockchain (expert)</button>
    </div>
  </div>
</header>

<main>
  <section class="view active" id="vDash" role="tabpanel" aria-labelledby="tDash">
    <div class="grid">
      <div class="card">
        <div class="k">TOTAL MWAL (unifi√©)</div>
        <div class="v mono" id="tot">‚Äî</div>
        <div class="small">Total = solde Wallet + solde Caisse (lecture locale). La valorisation (cours) vient de la blockchain commune.</div>
        <div class="row" style="margin-top:10px">
          <span class="pill"><span id="dotLocal" class="dot"></span><span id="stLocal">Lecture local‚Ä¶</span></span>
          <span class="pill">MAJ: <span class="mono" id="tsLocal">‚Äî</span></span>
        </div>
        <div class="row" style="margin-top:12px">
          <button id="btnOpenWallet">Ouvrir Wallet</button>
          <button id="btnOpenCaisse">Ouvrir Caisse</button>
          <button id="btnRefresh">Rafra√Æchir</button>
        </div>
        <hr style="border:0;border-top:1px solid var(--line);margin:14px 0"/>
        <div class="k">Bridge automatique vers la blockchain</div>
        <div class="row">
          <label class="pill"><input type="checkbox" id="autoBridge" checked> Auto-d√©p√¥t (Wallet + Caisse)</label>
          <label class="pill"><input type="checkbox" id="autoMine"> Auto-mine</label>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="small">‚Ç¨ auto (si tu veux cr√©er des blocs EXCHANGE donc un cours) :</span>
          <input id="autoEur" class="mono" style="min-width:280px" placeholder="ex: 25.00000000000000000000"/>
        </div>
        <hr style="border:0;border-top:1px solid var(--line);margin:14px 0"/>
        <div class="k">Envoi TOTAL (preuve de travail ‚Ä¢ cl√©+code+JSON ‚Ä¢ compatible caisse)</div>
        <div class="small">
          Ce module g√©n√®re un <span class="mono">MWAL_PACKAGE_V1</span> (cl√© + code AES-GCM + preuve <span class="mono">MWAL_MINING_V2</span>) comme le mineur V9.
          √Ä coller dans la <b>Caisse</b> (onglet Caisse ‚Üí Encaisser).
        </div>

        <div class="row" style="margin-top:10px">
          <input id="totTo" class="mono" style="min-width:260px" placeholder="TO (MWAL-POS-... ou MWAL-WALLET-...)"/>
          <input id="totFrom" style="min-width:220px" placeholder="FROM (optionnel)"/>
          <input id="totLabel" style="min-width:240px" placeholder="Libell√© (obligatoire)"/>
          <input id="totAmount" class="mono" style="min-width:220px" type="number" min="0" step="0.00000001" placeholder="Montant (MWAL)"/>
        </div>

        <div class="row" style="margin-top:10px">
          <span class="pill">Unit√©: <span class="mono" id="totUnitLbl">0.00000694444444444444</span></span>
          <span class="pill">Blocs: <span class="mono" id="totBlocksLbl">0</span></span>
          <span class="pill">Dur√©e: <span class="mono" id="totEtaLbl">0s</span></span>
          <label class="pill"><input type="checkbox" id="totPubGun" checked> Publier vers Render GUN (miner003_mined)</label>
        </div>

        <div class="row" style="margin-top:10px">
          <button id="btnTotStart">‚ñ∂ D√©marrer (PoW TOTAL)</button>
          <button id="btnTotPause" class="secondary" disabled>‚è∏ Pause</button>
          <button id="btnTotResume" class="secondary" disabled>‚ñ∂ Reprendre</button>
          <button id="btnTotCancel" class="warn" disabled>üßπ Annuler</button>
        </div>

        <div style="margin-top:10px">
          <div class="small mono" id="totProgTxt">0 / 0</div>
          <div style="width:100%;height:12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid var(--line);overflow:hidden">
            <div id="totProgBar" style="height:100%;width:0%;background:linear-gradient(90deg, rgba(110,231,255,.55), rgba(98,246,181,.35))"></div>
          </div>
          <div class="small" id="totStatus" style="margin-top:8px">Pr√™t.</div>
        </div>

        <div class="row" style="margin-top:12px">
          <div style="flex:1 1 320px">
            <div class="k">Cl√© MWAL</div>
            <textarea id="totOutKey" class="mono" rows="3" readonly placeholder="G√©n√©r√©e √† la fin"></textarea>
            <div class="row" style="margin-top:8px">
              <button id="btnTotCopyKey" class="secondary" disabled>üìã Copier la cl√©</button>
            </div>
          </div>
          <div style="flex:1 1 320px">
            <div class="k">Code chiffr√©</div>
            <textarea id="totOutCode" class="mono" rows="3" readonly placeholder="G√©n√©r√© √† la fin"></textarea>
            <div class="row" style="margin-top:8px">
              <button id="btnTotCopyCode" class="secondary" disabled>üìã Copier le code</button>
            </div>
          </div>
        </div>

        <div style="margin-top:12px">
          <div class="k">Preuve JSON (MWAL_MINING_V2) / Paquet (MWAL_PACKAGE_V1)</div>
          <textarea id="totOutJson" class="mono" rows="10" readonly placeholder="Preuve g√©n√©r√©e √† la fin"></textarea>
          <div class="row" style="margin-top:8px">
            <button id="btnTotCopyJson" class="secondary" disabled>üìã Copier JSON</button>
            <button id="btnTotCopyPkg" class="secondary" disabled>üìã Copier PACKAGE</button>
            <button id="btnTotDlProof" class="warn" disabled>üì¶ Export preuve .json</button>
            <button id="btnTotDlPkg" class="warn" disabled>üì¶ Export paquet .mwal.json</button>
          </div>
          <div class="small" style="margin-top:8px">
            Astuce : le <b>paquet</b> contient <span class="mono">key</span> + <span class="mono">code</span> + <span class="mono">proof</span>. Dans la Caisse : bouton ‚Äú‚ö° Importer paquet & Recevoir‚Äù.
          </div>
        </div>

      </div>

      <div class="card">
        <div class="k">Cours public (GUN Render) ‚Äî Blockchain commune</div>
        <div class="row">
          <span class="pill">Peer: <span class="mono" id="peerLbl">‚Äî</span></span>
          <span class="pill"><span id="dotGun" class="dot"></span><span id="stGun">Gun‚Ä¶</span></span>
        </div>
        <div class="row" style="margin-top:10px">
          <div style="flex:1;min-width:220px">
            <div class="k">Cours MWAL actuel</div>
            <div class="v mono" style="font-size:22px" id="rateMWAL">‚Äî</div>
          </div>
          <div style="flex:1;min-width:220px">
            <div class="k">Cours MWOLLOWM (d√©riv√©)</div>
            <div class="v mono" style="font-size:22px" id="rateMWOLLOWM">‚Äî</div>
          </div>
        </div>
        <div class="small" id="rateMeta" style="margin-top:8px">‚Äî</div>
        <canvas id="chart" width="900" height="260"></canvas>
        <div class="small" style="margin-top:8px">
          Le cours est publi√© par la blockchain via <span class="mono">MWAL_PUBLIC_COURSE_V1</span> (append-only) sur le peer Render.
        </div>
      </div>
    </div>
  </section>

  <section class="view" id="vWallet" role="tabpanel" aria-labelledby="tWallet">
    <iframe id="walletFrame" title="MWAL Wallet"></iframe>
    <div class="small" style="margin-top:10px">Le wallet publie ses stats dans Gun, mais les √©changes sont valoris√©s par la blockchain commune.</div>
  </section>

  <section class="view" id="vCaisse" role="tabpanel" aria-labelledby="tCaisse">
    <iframe id="caisseFrame" title="MWAL Caisse"></iframe>
    <div class="small" style="margin-top:10px">La caisse g√©n√®re des d√©p√¥ts blockchain automatiquement envoy√©s √† la blockchain commune.</div>
  </section>

  <section class="view" id="vExpert" role="tabpanel" aria-labelledby="tExpert">
    <iframe id="bcFrame" title="MWAL Blockchain (Gun Render)"></iframe>
    <div class="small" style="margin-top:10px">Mode expert : la blockchain compl√®te (import/minage/blocs). Par d√©faut, le syst√®me est automatis√©.</div>
  </section>

  <template id="walletTpl"><!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>MWAL ‚Äì Wallet Standard (PoCT + Gun Sync + Auto-Encaissement)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=JetBrains+Mono&display=swap');
    :root{
      --bg1:#000; --bg2:#001a00; --txt:#00ff66; --btn:#00ff66; --btn-h:#33ff99;
      --card:#001400; --border:#00ff66; --accent:#ffd700; --warn:#ffcc00; --bad:#ff4444; --cyan:#00ffff;
    }
    *{box-sizing:border-box;}
    body{margin:0;padding:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--txt);
      font-family:'JetBrains Mono',monospace;text-align:center;min-height:100vh;}
    h1{font-family:'Orbitron',sans-serif;margin:20px 10px 5px;text-shadow:0 0 15px var(--btn);font-size:2rem;}
    h2{font-family:'Orbitron',sans-serif;font-size:1.05rem;margin:8px 0;}
    p{margin:4px 0;}
    .wrap{max-width:1200px;margin:0 auto 30px;padding:8px;}
    .row{display:flex;flex-wrap:wrap;gap:12px;justify-content:center;margin-top:10px;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px;
      box-shadow:0 0 15px rgba(0,255,100,0.2);flex:1 1 360px;min-width:320px;text-align:left;}
    .card h2,.card p{text-align:center;}
    label{display:block;text-align:left;font-size:0.8rem;margin:4px 0 2px;}
    input,textarea,select{width:100%;background:#000;border:1px solid var(--border);border-radius:6px;color:var(--txt);
      padding:6px;font-family:'JetBrains Mono',monospace;font-size:0.85rem;}
    textarea{min-height:66px;resize:vertical;}
    .mainbtn,.sm-btn{background:var(--btn);color:#000;border:none;border-radius:8px;padding:7px 12px;cursor:pointer;
      font-weight:bold;margin:6px 4px 2px 0;font-size:0.82rem;}
    .sm-btn{padding:4px 10px;font-size:0.78rem;}
    .mainbtn:hover,.sm-btn:hover{background:var(--btn-h);}
    .danger-btn{background:var(--bad);color:#fff;}
    .danger-btn:hover{background:#ff6666;}
    .muted{opacity:0.85;font-size:0.78rem;}
    .alert{background:rgba(0,255,102,0.10);border:2px solid var(--border);border-radius:10px;padding:10px;margin:10px auto;
      max-width:1100px;font-size:0.9rem;text-align:center;}
    .alert.warn{border-color:var(--warn);color:var(--warn);background:rgba(255,204,0,0.07);}
    .alert.cyan{border-color:rgba(0,255,255,0.65);color:var(--cyan);background:rgba(0,255,255,0.06);}
    .stats-grid{display:grid;grid-template-columns:repeat(auto-fit, minmax(160px, 1fr));gap:8px;margin:8px 0;}
    .stat-box{background:rgba(0,255,102,0.05);border:1px solid var(--border);border-radius:10px;padding:8px;text-align:center;}
    .stat-label{font-size:0.7rem;opacity:0.75;margin-bottom:3px;}
    .stat-value{font-size:1.05rem;font-weight:bold;font-family:'Orbitron',sans-serif;word-break:break-word;}
    table{width:100%;border-collapse:collapse;font-size:0.75rem;margin-top:6px;}
    th,td{border:1px solid rgba(0,255,102,0.3);padding:4px 5px;text-align:left;}
    th{background:rgba(0,255,102,0.1);}
    .qr-container{margin-top:6px;display:inline-block;background:#fff;padding:3px;border-radius:6px;}
    .mwollowm-box{margin-top:8px;padding:6px;border:1px dashed rgba(255,215,0,0.55);border-radius:10px;
      background:rgba(255,215,0,0.05);text-align:center;}
    .mwollowm-value{font-size:1.05rem;font-weight:bold;font-family:'Orbitron',sans-serif;line-height:1.2;}
    .mwollowm-reached{color: var(--accent);text-shadow: 0 0 10px var(--accent);}
    .mwollowm-sub{font-size:0.75rem;opacity:0.9;margin-top:2px;}
    .mwollowm-progress-wrap{width:100%;height:10px;border:1px solid rgba(0,255,102,0.35);border-radius:999px;overflow:hidden;
      margin-top:6px;background:rgba(0,0,0,0.35);}
    .mwollowm-progress-bar{height:100%;width:0%;background:var(--txt);transition:width 250ms ease;}
    .mwollowm-progress-text{margin-top:4px;font-size:0.72rem;opacity:0.95;}
    footer{margin:10px 0 18px;font-size:0.75rem;opacity:0.65;text-align:center;}
    .codebox{background:#000;border:1px dashed rgba(0,255,102,0.6);border-radius:10px;padding:8px;}
    .center{text-align:center;}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(0,255,102,0.35);
      font-size:0.72rem;opacity:0.95;margin:2px 3px;}
    .toggleRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:6px}
    .toggleRow label{display:flex;gap:8px;align-items:center;justify-content:center;margin:0;width:auto}
    .small{font-size:0.72rem;opacity:0.85}
  </style>
</head>
<body>
  <h1>üëõ MWAL WALLET STANDARD</h1>

  <div class="alert">
    Send + Receive (codes sign√©s) + <strong>Encaissement PoCT via QR</strong> (t√©moin de blocs).
    <br/>‚úÖ <strong>Synchronis√© via Gun</strong> + ‚úÖ <strong>Auto-encaissement activable</strong>
  </div>

  <div class="wrap">

    <div class="row">
      <div class="card">
        <h2>üîå Synchronisation Gun</h2>
        <p class="muted center">Ce wallet publie <b>profil</b>, <b>stats</b> et <b>transactions</b> dans Gun. La visionneuse lit ces donn√©es.</p>
        <label>GUN_PEER_URL</label>
        <input id="gunPeer" placeholder="https://.../gun" />
        <button class="sm-btn" id="btnGunConnect">Connecter Gun</button>
        <p class="muted center" id="gunStatus">‚Äî</p>

        <div class="toggleRow">
          <label class="small">
            <input type="checkbox" id="autoReceiveOn">
            Auto-encaissement MWAL
          </label>
          <label class="small">
            <input type="checkbox" id="autoPoctOn">
            Auto-encaissement PoCT
          </label>
        </div>
        <p class="muted center small">Les boucles auto utilisent les m√™mes v√©rifications que les boutons (anti-rejeu, signatures, hash PoCT).</p>

        <div class="alert warn" style="margin-top:8px">
          ‚ö†Ô∏è Ne publie jamais de secrets dans Gun. Ici on publie uniquement: ID, nom, stats, tx.
        </div>
      </div>

      <div class="card">
        <h2>üÜî Mon wallet</h2>

        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-label">Solde</div>
            <div class="stat-value" id="balanceMWAL">0.00000000</div>
            <div class="stat-label">MWAL</div>

            <div class="mwollowm-box" id="mwollowmBox">
              <div class="stat-label">√âquivalent officiel</div>
              <div class="mwollowm-value" id="mwollowmValue">‚âà 0.00000000 MWOLLOWM</div>
              <div class="mwollowm-sub" id="mwollowmSub">--</div>
              <div class="mwollowm-progress-wrap" title="Progression vers le prochain MWOLLOWM">
                <div class="mwollowm-progress-bar" id="mwollowmProgressBar"></div>
              </div>
              <div class="mwollowm-progress-text muted" id="mwollowmProgressText"></div>
            </div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Transactions (local)</div>
            <div class="stat-value" id="txCount">0</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Min√© (PoCT)</div>
            <div class="stat-value" id="statMined">0.00000000</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Re√ßu</div>
            <div class="stat-value" id="statReceived">0.00000000</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Envoy√©</div>
            <div class="stat-value" id="statSent">0.00000000</div>
          </div>
        </div>

        <label>ID wallet</label>
        <input id="walletId" readonly />
        <div class="center"><div id="qrWallet" class="qr-container"></div></div>

        <label>Nom / Alias</label>
        <input id="walletName" placeholder="Ex : Alice, Boutique Laurent" />
        <button class="sm-btn" id="btnSaveName">Enregistrer le nom</button>

        <hr style="border-color:rgba(0,255,102,0.3);margin:10px 0;" />

        <h2>üßæ Export / Reset</h2>
        <button class="sm-btn" id="btnExportJson">Exporter JSON</button>
        <button class="sm-btn danger-btn" id="btnReset">R√©initialiser wallet</button>
        <textarea id="exportArea" readonly placeholder="Export JSON ici..."></textarea>

        <div class="alert warn" id="activationBox" style="display:none;margin-top:10px;">
          ‚è≥ Protocole non activ√©. Les transactions seront refus√©es avant la date GENESIS.
        </div>
      </div>

      <div class="card">
        <h2>üì• Recevoir (code MWAL)</h2>
        <p class="muted center">
          Collez la <strong>cl√© MWAL</strong> et le <strong>code chiffr√©</strong>. V√©rifie TO, TX, SIG.
        </p>

        <label for="recvKey">Cl√© MWAL re√ßue</label>
        <input id="recvKey" placeholder="MWAL-2026-XXXXXX" />

        <label for="recvCode">Code chiffr√© re√ßu</label>
        <textarea id="recvCode" placeholder="Coller ici le code chiffr√©."></textarea>

        <button class="mainbtn" id="btnReceive">Encaisser</button>
        <button class="sm-btn" id="btnClearRecv">Effacer</button>

        <label for="decodedPlain">Message d√©cod√©</label>
        <textarea id="decodedPlain" readonly></textarea>

        <p class="muted" id="recvStatus"></p>
      </div>

      <div class="card">
        <h2>üß¨ Encaisser PoCT (QR du t√©moin)</h2>
        <div class="alert cyan">
          Colle le texte du <strong>QR</strong> g√©n√©r√© par le t√©moin.
          <br/>Le wallet <strong>recalcule le hash</strong> et valide le bloc avant de cr√©diter.
        </div>

        <label for="poctText">Texte QR PoCT</label>
        <textarea id="poctText" placeholder="MWAL|POCT|MODE=official|BLOCK=...|TS=...|HASH=...|SALT=...|TO=MWAL-WAL-XXXXXX"></textarea>

        <div class="row" style="margin-top:6px;">
          <button class="mainbtn" id="btnPoctDecode">D√©coder / V√©rifier</button>
          <button class="sm-btn" id="btnPoctClaim">Encaisser la r√©compense</button>
          <button class="sm-btn danger-btn" id="btnPoctClear">Effacer</button>
        </div>

        <div class="codebox" style="margin-top:8px;">
          <div class="muted center">D√©tails PoCT</div>
          <div class="muted">
            <span class="pill" id="poctMode">MODE: ‚Äî</span>
            <span class="pill" id="poctBlock">BLOC: ‚Äî</span>
            <span class="pill" id="poctTs">TS: ‚Äî</span>
            <span class="pill" id="poctTo">TO: ‚Äî</span>
          </div>
          <label>Hash re√ßu</label>
          <textarea id="poctHashIn" readonly></textarea>
          <label>Hash recalcul√©</label>
          <textarea id="poctHashCalc" readonly></textarea>
          <p class="muted" id="poctStatus">‚Äî</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card" style="flex:1 1 100%;">
        <h2>üì§ Envoyer (g√©n√©rer un code)</h2>
        <p class="muted center">
          D√©bite votre solde local et g√©n√®re un <strong>code sign√©</strong> √† remettre au destinataire.
        </p>

        <div class="row">
          <div class="field" style="flex:1 1 320px;">
            <label for="sendTo">Wallet destinataire (TO)</label>
            <input id="sendTo" placeholder="MWAL-POS-XXXXXX ou MWAL-WAL-XXXXXX" />
          </div>
          <div class="field" style="flex:1 1 220px;">
            <label for="sendAmount">Montant (MWAL)</label>
            <input id="sendAmount" type="number" min="0" step="0.00000001" value="0.00000001" />
          </div>
          <div class="field" style="flex:1 1 280px;">
            <label for="sendLabel">Libell√© (optionnel)</label>
            <input id="sendLabel" placeholder="Ex : Paiement, Remboursement, Facture #123" />
          </div>
        </div>

        <button class="mainbtn" id="btnSend">G√©n√©rer l'envoi</button>

        <div id="sendOut" class="codebox" style="display:none;margin-top:8px;">
          <p class="center"><strong>‚úÖ Envoi g√©n√©r√©</strong> ‚Äî √† coller dans le wallet destinataire</p>
          <label>Cl√©</label>
          <input id="outKey" readonly />
          <label>Code</label>
          <textarea id="outCode" readonly></textarea>
        </div>

        <p class="muted" id="sendStatus"></p>
      </div>
    </div>

    <div class="row">
      <div class="card" style="flex:1 1 100%;">
        <h2>üìö Historique (local)</h2>
        <div style="max-height:300px;overflow:auto;">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Type</th>
                <th>TX</th>
                <th>De</th>
                <th>√Ä</th>
                <th>Montant (MWAL)</th>
                <th>Note</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <tr><td colspan="7" style="text-align:center;opacity:0.6;">Aucune transaction.</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
    <div class="completed-list" id="completedList">
    <strong>‚úÖ T√¢ches termin√©es</strong>
    <ul id="completedItems"><li>Aucune t√¢che termin√©e</li></ul>
  </div>

  <footer>¬© MWAL ‚Äì Wallet Standard + PoCT + Gun Sync + Auto-Encaissement</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>

<script>
/* =======================
   1) CONFIG GUN
======================= */
const DEFAULT_GUN_PEER = "https://gun-encaissement.onrender.com/gun";
const NS = { root: "mwal", v: "v1" };

let gun = null;
let net = null;

function connectGun(){
  const peer = (document.getElementById("gunPeer").value || DEFAULT_GUN_PEER).trim();
  document.getElementById("gunPeer").value = peer;
  try{
    gun = Gun({ peers:[peer], localStorage:false, radisk:false });
    net = gun.get(NS.root).get(NS.v);
    setGunStatus("‚úÖ Gun connect√© : " + peer);
    publishAll();
  }catch(e){
    console.error(e);
    setGunStatus("‚ùå Erreur Gun : " + e.message);
  }
}
function setGunStatus(txt){ document.getElementById("gunStatus").textContent = txt; }
function nowMs(){ return Date.now(); }

/* =======================
   2) CONFIG MWAL / PoCT
======================= */
const MWAL_PROTOCOL_SECRET = "MWAL_CORE_2025_V1_PROTOCOL";
const MWAL_PER_MWOLLOWM = 144000;
const MWAL_TO_MWOLLOWM  = 1 / MWAL_PER_MWOLLOWM;

const GENESIS_DATE_ISO = "";
const GENESIS_DATE_MS  = GENESIS_DATE_ISO ? new Date(GENESIS_DATE_ISO).getTime() : null;
function isProtocolActive(){
  if(!GENESIS_DATE_MS) return true;
  return Date.now() >= GENESIS_DATE_MS;
}

const POCT = {
  GENESIS_MS: new Date("2026-01-07T00:00:00+01:00").getTime(),
  BLOCK_INTERVAL_MS: 4000,
  BLOCKS_TOTAL: 2880000,
  REWARD_PER_BLOCK: 1 / 144000,
  ACCEPT_MODES: new Set(["official"]),
  FROM_ID: "MWAL-POCT-MINTER"
};

function computeSignature(fromId, amountStr, txId) {
  const raw = fromId + "|" + amountStr + "|" + txId + "|" + MWAL_PROTOCOL_SECRET;
  let h = 0;
  for (let i = 0; i < raw.length; i++) h = Math.imul(31, h) + raw.charCodeAt(i) | 0;
  return Math.abs(h).toString(36).toUpperCase();
}

/* =======================
   3) STORAGE
======================= */
const STORAGE_KEYS = {
  WALLET_ID:    "mwal_std_wallet_id",
  WALLET_NAME:  "mwal_std_wallet_name",
  STATE:        "mwal_std_state",
  PROCESSED:    "mwal_std_processed_txs",
  HISTORY:      "mwal_std_history",
  CLAIMED_POCT: "mwal_std_claimed_poct_blocks",
  GUN_PEER:     "mwal_gun_peer",
  AUTO_RECV:    "mwal_auto_receive_on",
  AUTO_POCT:    "mwal_auto_poct_on"
};

function saveToStorage(key, value) {
  try { localStorage.setItem(key, JSON.stringify(value)); }
  catch(e){ console.error("Erreur sauvegarde:", e); }
}
function loadFromStorage(key, def=null) {
  try {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : def;
  } catch(e){
    console.error("Erreur chargement:", e);
    return def;
  }
}

/* =======================
   4) UTILS
======================= */
function round8(x){ return Math.round((Number(x)||0) * 1e8) / 1e8; }
function formatDate(d){ return new Date(d).toLocaleString("fr-FR"); }

function safeQR(div, text, size){
  div.innerHTML = "";
  if(!text) return;
  new QRCode(div, { text, width:(size||128), height:(size||128) });
}

function hashSeed(str){
  let h = 0;
  for(let i=0;i<str.length;i++) h = Math.imul(31,h) + str.charCodeAt(i) | 0;
  return Math.abs(h);
}
function seededShuffle(arr, seed){
  arr = arr.slice();
  let m = arr.length, t, i;
  while(m){
    seed = (seed * 9301 + 49297) % 233280;
    i = Math.floor(seed / 233280 * m--);
    t = arr[m]; arr[m] = arr[i]; arr[i] = t;
  }
  return arr;
}
const pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
function genCode(ch){
  let s = hashSeed(ch + "_NA1C142");
  let out = "";
  for(let i=0;i<6;i++){
    s = (s * 9301 + 49297) % 233280;
    out += pool[Math.floor(s / 233280 * pool.length)];
  }
  return out.replace(/^([A-Z])/, ch === ch.toLowerCase() ? ch.toLowerCase() : ch.toUpperCase());
}
const baseAlphabet = {};
const allChars =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Ä√Ç√Ñ√É√†√¢√§√â√à√ä√ã√©√®√™√´√é√è√Æ√Ø√ì√ñ√¥√∂√ô√õ√ú√π√ª√º√á√ß0123456789.,!?;:'\"-_()@#%+/\\*=<>\n\t ";
for(const c of allChars) baseAlphabet[c] = (c === " ") ? " " : genCode(c);

let alphabet = {...baseAlphabet};
let inverse  = {};
function rebuildInverse(){
  inverse = {};
  for(const [k,v] of Object.entries(alphabet)) inverse[v] = k;
}
rebuildInverse();

function applyKeyToAlphabet(key){
  const seed = hashSeed(key);
  const keys = Object.keys(baseAlphabet).filter(c => c !== " ");
  const vals = Object.values(baseAlphabet).filter(c => c !== " ");
  const shuffled = seededShuffle(vals, seed);
  alphabet = {};
  keys.forEach((k,i)=> alphabet[k] = shuffled[i]);
  alphabet[" "] = " ";
  rebuildInverse();
}
function encodeString(str){
  let res = "";
  for(const ch of str) res += (alphabet[ch] ?? ch);
  return res;
}
function decodeString(cipher){
  let res = "";
  let i = 0;
  const entries = Object.entries(inverse).sort((a,b)=> b[0].length - a[0].length);
  while(i < cipher.length){
    let matched = false;
    for(const [code, plain] of entries){
      if(cipher.startsWith(code, i)){
        res += plain; i += code.length; matched = true; break;
      }
    }
    if(!matched){ res += cipher[i]; i++; }
  }
  return res;
}

async function sha256(text){
  const data = new TextEncoder().encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, "0")).join("");
}
async function computePoctHash(blockIndex, salt){
  const blockTs = POCT.GENESIS_MS + (blockIndex * POCT.BLOCK_INTERVAL_MS);
  return sha256(`MWAL|BLOCK|${blockIndex}|${blockTs}|SALT|${salt || ""}`);
}

function generateKey(){
  const y = new Date().getFullYear();
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let s = "";
  for(let i=0;i<6;i++) s += chars[Math.floor(Math.random()*chars.length)];
  return `MWAL-${y}-${s}`;
}
function generateWalletId(){
  if(crypto && crypto.randomUUID) return "MWAL-WAL-" + crypto.randomUUID().slice(0,8).toUpperCase();
  return "MWAL-WAL-" + Math.random().toString(36).slice(2,10).toUpperCase();
}

/* =======================
   5) STATE + LEDGER
======================= */
let myWalletId = null;
let myWalletName = "";
let processedTxs = [];
let history = [];
let claimedPoct = new Set();

function getState(){
  const st = loadFromStorage(STORAGE_KEYS.STATE, {balance:0});
  return { balance: Number(st.balance) || 0 };
}
function setState(st){
  saveToStorage(STORAGE_KEYS.STATE, { balance: round8(Number(st.balance) || 0) });
}
function addHistory(entry){
  history.push(entry);
  saveToStorage(STORAGE_KEYS.HISTORY, history);
  publishTx(entry);
  publishStatsDebounced();
}
function saveClaimedPoct(){
  saveToStorage(STORAGE_KEYS.CLAIMED_POCT, Array.from(claimedPoct.values()));
}

/* =======================
   6) GUN PUBLISH
======================= */
function gunPathWallet(){
  if(!net || !myWalletId) return null;
  return net.get("wallets").get(myWalletId);
}
function publishIndexAndProfile(){
  if(!net) return;
  net.get("walletIndex").get(myWalletId).put({ id: myWalletId, name: myWalletName || "", lastSeen: nowMs() });
  net.get("lastSeen").put({ ts: nowMs() });
  const w = gunPathWallet(); if(!w) return;
  w.get("profile").put({ id: myWalletId, name: myWalletName || "", updatedAt: nowMs() });
}
function computeAggregates(){
  let totalMined=0, totalReceived=0, totalSent=0;
  for(const tx of history){
    const a = Number(tx.amount||0);
    if(tx.type === "POCT") totalMined += a;
    else if(tx.type === "RECEIVE") totalReceived += a;
    else if(tx.type === "SEND") totalSent += a;
  }
  return {
    totalMined: round8(totalMined),
    totalReceived: round8(totalReceived),
    totalSent: round8(totalSent),
    txCount: history.length
  };
}
let __statsTimer = null;
function publishStatsDebounced(){
  if(__statsTimer) clearTimeout(__statsTimer);
  __statsTimer = setTimeout(publishStats, 150);
}
function publishStats(){
  const w = gunPathWallet();
  if(!w) return;
  const st = getState();
  const agg = computeAggregates();
  w.get("stats").put({
    id: myWalletId,
    name: myWalletName || "",
    balance: round8(st.balance),
    ...agg,
    lastSeen: nowMs(),
    version: "wallet-standard-poct+gun+auto-1.0"
  });
  publishIndexAndProfile();
  document.getElementById("statMined").textContent = agg.totalMined.toFixed(8);
  document.getElementById("statReceived").textContent = agg.totalReceived.toFixed(8);
  document.getElementById("statSent").textContent = agg.totalSent.toFixed(8);
}
function publishTx(tx){
  const w = gunPathWallet();
  if(!w || !tx) return;
  const txId = tx.txId || ("TX-" + nowMs());
  w.get("txs").get(txId).put({
    txId,
    type: tx.type || "",
    fromId: tx.fromId || "",
    toId: tx.toId || "",
    amount: round8(Number(tx.amount||0)),
    note: tx.note || "",
    ts: (tx.date ? new Date(tx.date).getTime() : nowMs())
  });
}
function publishAll(){
  publishIndexAndProfile();
  publishStats();
  history.slice().sort((a,b)=> new Date(b.date)-new Date(a.date)).slice(0,50).forEach(publishTx);
}

/* =======================
   7) UI
======================= */
function updateBalances(){
  const balance = round8(getState().balance);
  document.getElementById("balanceMWAL").textContent = balance.toFixed(8);

  const mwollowm = balance * MWAL_TO_MWOLLOWM;
  const reachedInt = Math.floor(mwollowm + 1e-15);
  const valEl = document.getElementById("mwollowmValue");
  const subEl = document.getElementById("mwollowmSub");
  const barEl = document.getElementById("mwollowmProgressBar");
  const txtEl = document.getElementById("mwollowmProgressText");

  if(reachedInt >= 1){
    valEl.innerHTML = `<span class="mwollowm-reached">‚úî OFFICIEL : ${reachedInt} MWOLLOWM</span>`;
  } else {
    valEl.textContent = `‚âà ${mwollowm.toFixed(8)} MWOLLOWM`;
  }
  subEl.textContent = `1 MWAL = ${MWAL_TO_MWOLLOWM} MWOLLOWM ‚Ä¢ ${MWAL_PER_MWOLLOWM} MWAL = 1 MWOLLOWM`;

  const progress = Math.min(1, Math.max(0, mwollowm - reachedInt));
  barEl.style.width = (progress * 100).toFixed(2) + "%";
  const remainingMWAL = Math.max(0, ((reachedInt+1) * MWAL_PER_MWOLLOWM) - balance);
  txtEl.textContent = `Progression vers ${reachedInt+1} MWOLLOWM : ${(progress*100).toFixed(2)}% ‚Ä¢ Reste ${remainingMWAL.toFixed(8)} MWAL`;

  document.getElementById("txCount").textContent = String(history.length);
}
function updateHistoryTable(){
  const tbody = document.getElementById("historyBody");
  tbody.innerHTML = "";
  if(!history || history.length === 0){
    tbody.innerHTML = `<tr><td colspan="7" style="text-align:center;opacity:0.6;">Aucune transaction.</td></tr>`;
    return;
  }
  history.slice().sort((a,b)=> new Date(b.date)-new Date(a.date)).forEach(tx=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${formatDate(tx.date)}</td>
      <td>${tx.type || "-"}</td>
      <td>${tx.txId || "-"}</td>
      <td>${tx.fromId || "-"}</td>
      <td>${tx.toId || "-"}</td>
      <td>${Number(tx.amount||0).toFixed(8)}</td>
      <td>${tx.note || ""}</td>
    `;
    tbody.appendChild(tr);
  });
}
function updateWalletView(){
  document.getElementById("walletId").value = myWalletId;
  document.getElementById("walletName").value = myWalletName;
  safeQR(document.getElementById("qrWallet"), myWalletId, 96);

  const box = document.getElementById("activationBox");
  if(!isProtocolActive()){
    box.style.display = "block";
    box.innerHTML = GENESIS_DATE_MS
      ? `‚è≥ Protocole non activ√©. Transactions refus√©es avant : <strong>${new Date(GENESIS_DATE_MS).toLocaleString("fr-FR")}</strong>`
      : "‚è≥ Protocole non activ√©.";
  }else box.style.display = "none";

  updateBalances();
  updateHistoryTable();
  publishStatsDebounced();
}

/* =======================
   8) RECEIVE
======================= */
function parsePlain(plain){
  const get = (re) => (plain.match(re) || [])[1] || null;
  return {
    txId: get(/TX=([^|]+)/),
    fromId: get(/FROM=([^|]+)/),
    fromName: get(/FROM_NAME=([^|]+)/),
    toId: get(/TO=([^|]+)/),
    amountStr: get(/AMOUNT=([0-9]*\.?[0-9]+)/),
    sig: get(/SIG=([^|]+)/),
    note: get(/LABEL=([^|]+)/)
  };
}

function receiveProcess(key, cipher){
  const recvStatusEl = document.getElementById("recvStatus");
  recvStatusEl.textContent = "";
  document.getElementById("decodedPlain").value = "";

  if(!isProtocolActive()){
    recvStatusEl.textContent = "‚è≥ Protocole non activ√© : r√©ception refus√©e avant la date GENESIS.";
    return false;
  }
  if(!key || !cipher){
    recvStatusEl.textContent = "‚ùå Cl√© et code requis.";
    return false;
  }
  if(!key.startsWith("MWAL-")){
    recvStatusEl.textContent = "‚ùå Cl√© MWAL invalide.";
    return false;
  }

  applyKeyToAlphabet(key);
  const plain = decodeString(cipher);
  document.getElementById("decodedPlain").value = plain;

  const p = parsePlain(plain);
  if(!p.amountStr || !p.toId || !p.fromId || !p.txId || !p.sig){
    recvStatusEl.textContent = "‚ö†Ô∏è Message incomplet ou non sign√©.";
    return false;
  }
  if(p.toId !== myWalletId){
    recvStatusEl.textContent = `‚ö†Ô∏è Code destin√© √† ${p.toId}, pas √† ce wallet (${myWalletId}).`;
    return false;
  }
  if(processedTxs.includes(p.txId)){
    recvStatusEl.textContent = "‚ùå Transaction d√©j√† encaiss√©e (rejeu bloqu√©).";
    return false;
  }

  let amount = round8(parseFloat(p.amountStr));
  if(!Number.isFinite(amount) || amount <= 0){
    recvStatusEl.textContent = "‚ö†Ô∏è Montant invalide.";
    return false;
  }
  const amountFixed = amount.toFixed(8);
  const expectedSig = computeSignature(p.fromId, amountFixed, p.txId);
  if(p.sig !== expectedSig){
    recvStatusEl.textContent = "‚ùå Signature MWAL invalide ‚Äì paiement refus√©.";
    return false;
  }

  const st = getState();
  st.balance = round8(st.balance + amount);
  setState(st);

  processedTxs.push(p.txId);
  saveToStorage(STORAGE_KEYS.PROCESSED, processedTxs);

  addHistory({
    type: "RECEIVE",
    txId: p.txId,
    fromId: p.fromName ? `${p.fromName} (${p.fromId})` : p.fromId,
    toId: myWalletName ? `${myWalletName} (${myWalletId})` : myWalletId,
    amount,
    date: new Date().toISOString(),
    note: p.note || ""
  });

  updateWalletView();
  recvStatusEl.textContent = "‚úÖ Encaissement OK (signature valide).";
  return true;
}

document.getElementById("btnReceive").onclick = () => {
  try{
    const key = document.getElementById("recvKey").value.trim();
    const cipher = document.getElementById("recvCode").value.trim();
    receiveProcess(key, cipher);
  }catch(e){
    console.error(e);
    document.getElementById("recvStatus").textContent = "‚ùå Erreur lors du d√©codage / encaissement : " + e.message;
  }
};

document.getElementById("btnClearRecv").onclick = () => {
  document.getElementById("recvKey").value = "";
  document.getElementById("recvCode").value = "";
  document.getElementById("decodedPlain").value = "";
  document.getElementById("recvStatus").textContent = "";
};

/* =======================
   9) POCT
======================= */
let lastPoct = null;

function parsePoctText(txt){
  const parts = (txt || "").trim().split("|").filter(Boolean);
  if(parts.length < 3) return null;
  if(parts[0] !== "MWAL" || parts[1] !== "POCT") return null;

  const kv = {};
  for(let i=2;i<parts.length;i++){
    const seg = parts[i];
    const idx = seg.indexOf("=");
    if(idx === -1) continue;
    kv[seg.slice(0, idx).trim()] = seg.slice(idx+1).trim();
  }

  const mode = kv.MODE || "official";
  const block = Number(kv.BLOCK);
  const ts = Number(kv.TS);
  const hash = (kv.HASH || "").toLowerCase();
  const salt = kv.SALT || "";
  const to = (kv.TO || "").trim();

  if(!Number.isFinite(block) || block < 0) return null;
  if(!Number.isFinite(ts) || ts <= 0) return null;
  if(!hash || hash.length < 16) return null;

  return {mode, block, ts, hash, salt, to};
}

function setPoctUiEmpty(){
  document.getElementById("poctMode").textContent = "MODE: ‚Äî";
  document.getElementById("poctBlock").textContent = "BLOC: ‚Äî";
  document.getElementById("poctTs").textContent = "TS: ‚Äî";
  document.getElementById("poctTo").textContent = "TO: ‚Äî";
  document.getElementById("poctHashIn").value = "";
  document.getElementById("poctHashCalc").value = "";
  document.getElementById("poctStatus").textContent = "‚Äî";
  lastPoct = null;
}
function setPoctStatus(msg){ document.getElementById("poctStatus").textContent = msg; }

document.getElementById("btnPoctClear").onclick = () => {
  document.getElementById("poctText").value = "";
  setPoctUiEmpty();
};

document.getElementById("btnPoctDecode").onclick = async () => {
  const txt = document.getElementById("poctText").value;
  setPoctUiEmpty();

  if(!txt.trim()){ setPoctStatus("‚ùå Colle le texte du QR PoCT."); return; }

  const p = parsePoctText(txt);
  if(!p){ setPoctStatus("‚ùå Format PoCT invalide."); return; }

  document.getElementById("poctMode").textContent = `MODE: ${p.mode}`;
  document.getElementById("poctBlock").textContent = `BLOC: ${p.block.toLocaleString("fr-FR")}`;
  document.getElementById("poctTs").textContent = `TS: ${new Date(p.ts).toLocaleString("fr-FR")}`;
  document.getElementById("poctTo").textContent = `TO: ${p.to || "‚Äî"}`;
  document.getElementById("poctHashIn").value = p.hash;

  if(!p.to){ setPoctStatus("‚ùå QR PoCT sans TO : refus√©."); lastPoct = {...p, ok:false, hashCalc:""}; return; }
  if(p.to !== myWalletId){ setPoctStatus(`‚ùå TO invalide : destin√© √† ${p.to}, pas √† ${myWalletId}.`); lastPoct = {...p, ok:false, hashCalc:""}; return; }
  if(!POCT.ACCEPT_MODES.has(p.mode)){ setPoctStatus(`‚ùå Mode refus√© (${p.mode}).`); lastPoct = {...p, ok:false, hashCalc:""}; return; }

  const expectedTs = POCT.GENESIS_MS + (p.block * POCT.BLOCK_INTERVAL_MS);
  if(p.ts !== expectedTs){ setPoctStatus("‚ùå Timestamp invalide pour ce bloc."); lastPoct = {...p, ok:false, hashCalc:""}; return; }
  if(p.block >= POCT.BLOCKS_TOTAL){ setPoctStatus("‚ùå Bloc hors plage."); lastPoct = {...p, ok:false, hashCalc:""}; return; }

  const hashCalc = await computePoctHash(p.block, p.salt);
  document.getElementById("poctHashCalc").value = hashCalc;

  const ok = (hashCalc.toLowerCase() === p.hash.toLowerCase());
  lastPoct = {...p, ok, hashCalc};

  if(!ok){ setPoctStatus("‚ùå Hash invalide : recalcul diff√©rent."); return; }
  if(claimedPoct.has(p.block)){ setPoctStatus("‚ö†Ô∏è Bloc d√©j√† encaiss√© dans ce wallet."); return; }

  setPoctStatus(`‚úÖ PoCT valide. R√©compense : ${round8(POCT.REWARD_PER_BLOCK).toFixed(8)} MWAL (bloc #${p.block}).`);
};

document.getElementById("btnPoctClaim").onclick = () => {
  if(!isProtocolActive()){ setPoctStatus("‚è≥ Protocole non activ√© : encaissement refus√©."); return; }
  if(!lastPoct){ setPoctStatus("‚ùå D'abord : D√©coder / V√©rifier le QR PoCT."); return; }
  if(!lastPoct.ok){ setPoctStatus("‚ùå PoCT non valide. Encaissement refus√©."); return; }
  if(claimedPoct.has(lastPoct.block)){ setPoctStatus("‚ùå Ce bloc est d√©j√† encaiss√© dans ce wallet."); return; }

  const amount = round8(POCT.REWARD_PER_BLOCK);
  const st = getState();
  st.balance = round8(st.balance + amount);
  setState(st);

  claimedPoct.add(lastPoct.block);
  saveClaimedPoct();

  const txId = `POCT-${lastPoct.mode}-B${lastPoct.block}-${(lastPoct.hash || "").slice(0,10)}`;
  addHistory({
    type: "POCT",
    txId,
    fromId: POCT.FROM_ID,
    toId: myWalletName ? `${myWalletName} (${myWalletId})` : myWalletId,
    amount,
    date: new Date().toISOString(),
    note: `Bloc #${lastPoct.block} ‚Ä¢ hash OK`
  });

  updateWalletView();
  setPoctStatus(`üéâ R√©compense encaiss√©e : +${amount.toFixed(8)} MWAL (bloc #${lastPoct.block}).`);
};

/* =======================
   10) SEND
======================= */
document.getElementById("btnSend").onclick = () => {
  const status = document.getElementById("sendStatus");
  status.textContent = "";
  document.getElementById("sendOut").style.display = "none";

  if(!isProtocolActive()){ status.textContent = "‚è≥ Protocole non activ√© : envoi refus√©."; return; }

  const toWallet = document.getElementById("sendTo").value.trim();
  if(!toWallet){ status.textContent = "‚ùå Veuillez saisir l'ID du wallet destinataire."; return; }

  let amount = parseFloat((document.getElementById("sendAmount").value || "0").replace(",", "."));
  if(!Number.isFinite(amount) || amount <= 0){ status.textContent = "‚ùå Montant invalide."; return; }
  amount = round8(amount);
  const amountStr = amount.toFixed(8);

  const note = (document.getElementById("sendLabel").value || "").trim();

  const st = getState();
  if(st.balance < amount){ status.textContent = `‚ùå Solde insuffisant. Solde: ${round8(st.balance).toFixed(8)} MWAL`; return; }

  const txId = "TX-" + Date.now().toString(36);
  const sig  = computeSignature(myWalletId, amountStr, txId);

  const plain =
    `TX=${txId}|FROM=${myWalletId}|FROM_NAME=${(myWalletName || "WALLET")}|TO=${toWallet}|TO_NAME=WALLET|AMOUNT=${amountStr}|UNIT=MWAL` +
    (note ? `|LABEL=${note}` : "") +
    `|SIG=${sig}`;

  const key = generateKey();
  applyKeyToAlphabet(key);
  const cipher = encodeString(plain);

  st.balance = round8(st.balance - amount);
  setState(st);

  addHistory({
    type: "SEND",
    txId,
    fromId: myWalletName ? `${myWalletName} (${myWalletId})` : myWalletId,
    toId: toWallet,
    amount,
    date: new Date().toISOString(),
    note
  });

  updateWalletView();

  document.getElementById("outKey").value = key;
  document.getElementById("outCode").value = cipher;
  document.getElementById("sendOut").style.display = "block";
  status.textContent = "‚úÖ Code g√©n√©r√©. Donnez la cl√© + le code au destinataire.";
};

/* =======================
   11) SETTINGS / EXPORT / RESET
======================= */
document.getElementById("btnSaveName").onclick = () => {
  myWalletName = document.getElementById("walletName").value.trim();
  saveToStorage(STORAGE_KEYS.WALLET_NAME, myWalletName);
  updateWalletView();
  publishIndexAndProfile();
  alert("‚úÖ Nom sauvegard√©");
};

document.getElementById("btnExportJson").onclick = () => {
  const data = {
    version: "wallet-standard-poct+gun+auto-1.0",
    exportDate: new Date().toISOString(),
    walletId: myWalletId,
    walletName: myWalletName,
    state: getState(),
    aggregates: computeAggregates(),
    processedTxs,
    history,
    genesisDateISO: GENESIS_DATE_ISO || null,
    gun: { peer: (document.getElementById("gunPeer").value || DEFAULT_GUN_PEER).trim(), namespace: NS },
    auto: { autoReceiveOn: !!document.getElementById("autoReceiveOn").checked, autoPoctOn: !!document.getElementById("autoPoctOn").checked }
  };
  document.getElementById("exportArea").value = JSON.stringify(data, null, 2);
};

document.getElementById("btnReset").onclick = () => {
  if(!confirm("‚ö†Ô∏è R√©initialiser le wallet ?\nSolde + historique + anti-rejeu seront effac√©s.")) return;

  setState({balance:0});
  processedTxs = [];
  history = [];
  claimedPoct = new Set();

  saveToStorage(STORAGE_KEYS.PROCESSED, processedTxs);
  saveToStorage(STORAGE_KEYS.HISTORY, history);
  saveToStorage(STORAGE_KEYS.CLAIMED_POCT, []);

  document.getElementById("exportArea").value = "";
  setPoctUiEmpty();
  updateWalletView();

  publishAll();
  alert("‚úÖ Wallet r√©initialis√©");
};

document.getElementById("btnGunConnect").onclick = () => {
  saveToStorage(STORAGE_KEYS.GUN_PEER, (document.getElementById("gunPeer").value||DEFAULT_GUN_PEER).trim());
  connectGun();
};

/* =======================
   12) AUTO-ENCAISSEMENT
======================= */
let __autoRecvLock = false;
let __autoPoctLock = false;

function autoReceiveLoop(){
  if(!document.getElementById("autoReceiveOn").checked) return;

  const keyEl = document.getElementById("recvKey");
  const codeEl = document.getElementById("recvCode");
  const key = keyEl.value.trim();
  const code = codeEl.value.trim();
  if(!key || !code) return;

  if(__autoRecvLock) return;
  __autoRecvLock = true;

  try{
    const ok = receiveProcess(key, code);
    if(ok){ keyEl.value = ""; codeEl.value = ""; }
  }catch(e){ console.warn("AutoReceive skip:", e.message); }

  setTimeout(()=>{ __autoRecvLock = false; }, 900);
}

async function autoPoctLoop(){
  if(!document.getElementById("autoPoctOn").checked) return;

  const txtEl = document.getElementById("poctText");
  const txt = txtEl.value.trim();
  if(!txt) return;

  if(__autoPoctLock) return;
  __autoPoctLock = true;

  try{
    await document.getElementById("btnPoctDecode").onclick();
    const status = document.getElementById("poctStatus").textContent || "";
    if(status.includes("PoCT valide")){
      document.getElementById("btnPoctClaim").click();
      txtEl.value = "";
    }
  }catch(e){ console.warn("AutoPoCT skip:", e.message); }

  setTimeout(()=>{ __autoPoctLock = false; }, 1200);
}

/* =======================
   13) INIT
======================= */
function initWallet(){
  myWalletId = loadFromStorage(STORAGE_KEYS.WALLET_ID);
  if(!myWalletId){
    myWalletId = generateWalletId();
    saveToStorage(STORAGE_KEYS.WALLET_ID, myWalletId);
  }
  myWalletName = loadFromStorage(STORAGE_KEYS.WALLET_NAME, "");
  processedTxs = loadFromStorage(STORAGE_KEYS.PROCESSED, []);
  history = loadFromStorage(STORAGE_KEYS.HISTORY, []) || [];

  const claimedArr = loadFromStorage(STORAGE_KEYS.CLAIMED_POCT, []);
  claimedPoct = new Set((claimedArr || []).map(Number).filter(Number.isFinite));

  const peer = loadFromStorage(STORAGE_KEYS.GUN_PEER, DEFAULT_GUN_PEER) || DEFAULT_GUN_PEER;
  document.getElementById("gunPeer").value = peer;

  const autoRecv = !!loadFromStorage(STORAGE_KEYS.AUTO_RECV, true);
  const autoPoct = !!loadFromStorage(STORAGE_KEYS.AUTO_POCT, true);
  document.getElementById("autoReceiveOn").checked = autoRecv;
  document.getElementById("autoPoctOn").checked = autoPoct;

  document.getElementById("autoReceiveOn").addEventListener("change", (e)=>{
    saveToStorage(STORAGE_KEYS.AUTO_RECV, !!e.target.checked);
  });
  document.getElementById("autoPoctOn").addEventListener("change", (e)=>{
    saveToStorage(STORAGE_KEYS.AUTO_POCT, !!e.target.checked);
  });

  updateWalletView();
  setPoctUiEmpty();
  connectGun();
}

// pr√©sence + stats
setInterval(()=>{ if(net) publishStats(); }, 10000);
// boucles auto
setInterval(autoReceiveLoop, 900);
setInterval(()=>{ autoPoctLoop(); }, 1300);

initWallet();
</script>
</body>
</html>
</template>
  <template id="caisseTpl"><!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MWAL ‚Äî Caisse (OFFLINE ‚Ä¢ COFFRE-FORT ‚Ä¢ Import JSON obligatoire ‚Ä¢ POS‚ÄëMining interne)</title>
<style>
:root{
  --bg:#070a08;--panel:#0d1510;--panel2:#0a100c;--ink:#bfffdc;--ink2:#6dffb3;--muted:#8bb99e;
  --line:rgba(109,255,179,.16);--ok:#6dffb3;--warn:#ffd34d;--bad:#ff5a6a;--shadow:0 10px 30px rgba(0,0,0,.45);
}
*{box-sizing:border-box}
body{margin:0;color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  background:radial-gradient(900px 500px at 10% 0%, rgba(109,255,179,.10), transparent 60%),
             radial-gradient(900px 500px at 90% 10%, rgba(255,211,77,.06), transparent 60%),var(--bg);}
.wrap{max-width:1220px;margin:18px auto;padding:0 14px}
header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:14px}
.brand{display:flex;align-items:center;gap:10px}
.logo{width:42px;height:42px;border-radius:14px;border:1px solid rgba(109,255,179,.25);
  background:linear-gradient(135deg, rgba(109,255,179,.16), rgba(255,211,77,.12));box-shadow:var(--shadow);position:relative;}
.logo:after{content:"";position:absolute;inset:10px;border-radius:12px;background:linear-gradient(135deg, rgba(109,255,179,.35), rgba(255,211,77,.18));}
h1{margin:0;font-size:18px;color:var(--ink2)}
.sub{margin-top:2px;color:var(--muted);font-size:12px;max-width:820px}
.pill{display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:8px 10px;border-radius:12px;background:rgba(13,21,16,.75);
  border:1px solid rgba(109,255,179,.18);box-shadow:0 6px 18px rgba(0,0,0,.28)}
.pill b{color:var(--ink2)}
.grid{display:grid;grid-template-columns:1.05fr .95fr;gap:12px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
.card{background:linear-gradient(180deg, rgba(13,21,16,.88), rgba(10,16,12,.88));
  border:1px solid rgba(109,255,179,.18);border-radius:18px;box-shadow:var(--shadow);overflow:hidden;}
.hd{padding:12px 14px;border-bottom:1px solid rgba(109,255,179,.12);display:flex;justify-content:space-between;align-items:center;gap:10px}
.hd h2{margin:0;font-size:14px;color:var(--ink2)}
.bd{padding:14px}
label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px}
input,textarea,select{width:100%;border-radius:12px;padding:10px 10px;background:rgba(8,12,9,.75);
  border:1px solid rgba(109,255,179,.18);color:var(--ink);outline:none;}
textarea{min-height:88px;resize:vertical}
input:focus,textarea:focus,select:focus{border-color:rgba(109,255,179,.35)}
.row{display:flex;gap:10px;flex-wrap:wrap}
.row>*{flex:1 1 220px}
.btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
button{border:none;padding:10px 12px;border-radius:12px;cursor:pointer;background:linear-gradient(180deg, rgba(16,32,23,.9), rgba(10,18,12,.9));
  border:1px solid rgba(109,255,179,.2);color:var(--ink2);box-shadow:0 6px 18px rgba(0,0,0,.35);transition:transform .06s ease;}
button:hover{background:linear-gradient(180deg, rgba(22,44,31,.95), rgba(10,18,12,.95))}
button:active{transform:translateY(1px)}
button.secondary{color:var(--ink)}
button.warn{border-color:rgba(255,211,77,.35);color:#ffe6a7}
button.bad{border-color:rgba(255,90,106,.35);color:#ffd0d6}
button:disabled{opacity:.45;cursor:not-allowed}
.stats{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.stat{background:rgba(8,12,9,.55);border:1px solid rgba(109,255,179,.14);border-radius:16px;padding:12px}
.stat .lbl{font-size:12px;color:var(--muted)}
.stat .val{font-size:18px;color:var(--ink2);margin:6px 0 3px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}
.status{margin-top:10px;padding:10px 12px;border-radius:14px;background:rgba(8,12,9,.5);border:1px solid rgba(109,255,179,.12);font-size:12px;color:var(--muted);white-space:pre-wrap}
.status.ok{color:var(--ok)}
.status.warn{color:var(--warn)}
.status.err{color:var(--bad)}
.sep{height:1px;background:rgba(109,255,179,.12);margin:12px 0}
.hint{background:rgba(109,255,179,.08);border:1px solid rgba(109,255,179,.12);padding:10px 12px;border-radius:14px;font-size:12px;color:var(--muted)}
.list{max-height:280px;overflow:auto;border:1px solid rgba(109,255,179,.12);border-radius:14px;padding:10px;background:rgba(8,12,9,.35)}
.item{padding:10px;border:1px solid rgba(109,255,179,.12);border-radius:14px;margin-bottom:10px;background:rgba(8,12,9,.35)}
.item:last-child{margin-bottom:0}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
@media(max-width:780px){.grid2{grid-template-columns:1fr}}
.progress{width:100%;height:12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(109,255,179,.14);overflow:hidden}
.progress>div{height:100%;width:0%;background:linear-gradient(90deg, rgba(109,255,179,.6), rgba(255,211,77,.45))}
.tag{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid rgba(109,255,179,.18);background:rgba(8,12,9,.45);font-size:11px;color:var(--muted)}
.small{font-size:12px;color:var(--muted)}
/* ===== Modal assistant import ledger ===== */
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:14px;z-index:9999;}
.modal{width:min(860px,100%);background:linear-gradient(180deg, rgba(13,21,16,.96), rgba(10,16,12,.96));
  border:1px solid rgba(109,255,179,.22);border-radius:18px;box-shadow:var(--shadow);overflow:hidden;}
.modal-hd{padding:12px 14px;border-bottom:1px solid rgba(109,255,179,.12);display:flex;justify-content:space-between;align-items:center;gap:10px}
.modal-hd h3{margin:0;font-size:14px;color:var(--ink2)}
.modal-bd{padding:14px}
.kv{display:grid;grid-template-columns:170px 1fr;gap:8px 12px;font-size:12px}
.kv .k{color:var(--muted)}
.kv .v{color:var(--ink)}
.pillbox{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.pilltag{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(109,255,179,.18);background:rgba(8,12,9,.45);font-size:12px;color:var(--muted)}
.pilltag.ok{color:var(--ok);border-color:rgba(109,255,179,.25)}
.pilltag.warn{color:var(--warn);border-color:rgba(255,211,77,.35)}
.pilltag.err{color:var(--bad);border-color:rgba(255,90,106,.35)}
.radioRow{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
.radioRow label{display:flex;align-items:flex-start;gap:8px;cursor:pointer;background:rgba(8,12,9,.35);border:1px solid rgba(109,255,179,.12);padding:10px 12px;border-radius:14px;min-width:220px}
.radioRow input{width:auto;margin-top:3px}
.modal-ft{padding:12px 14px;border-top:1px solid rgba(109,255,179,.12);display:flex;justify-content:flex-end;gap:10px;flex-wrap:wrap}
pre.codebox{margin:10px 0 0;background:rgba(8,12,9,.45);border:1px solid rgba(109,255,179,.12);padding:10px;border-radius:14px;max-height:180px;overflow:auto;font-size:12px}
</style>
</head>

<body>
<div class="wrap">
<header>
  <div class="brand">
    <div class="logo"></div>
    <div>
      <h1>MWAL ‚Äî Caisse (OFFLINE) üîê Coffre-fort</h1>
      <div class="sub">Import JSON obligatoire (preuve + cl√© + code). POS-mining interne pour caisse‚Üícaisse. Ledger sign√© ECDSA + mode coffre-fort + verrou anti-onglets.</div>
    </div>
  </div>
  <div class="pill small">
    <span>ID de la caisse</span> <b class="mono" id="posIdLbl">MWAL-POS-XXXXXX</b>
    <button class="secondary" id="btnCopyPos">üìã Copier ID</button>
  </div>
</header>

<div class="grid">
  <div class="card">
    <div class="hd"><h2>üí≥ Encaisser (import JSON obligatoire)</h2><span class="tag">STRICT</span></div>
    <div class="bd">
      <div class="row">
        <div>
          <label>Cl√© MWAL</label>
          <textarea id="inKey" class="mono" placeholder="MWAL|TX=...|FROM=...|TO=MWAL-POS-XXXXXX|AMOUNT=..."></textarea>
        </div>
        <div>
          <label>Code chiffr√©</label>
          <textarea id="inCode" class="mono" placeholder="MWAL-AESGCM|IV|CIPHERTEXT"></textarea>
        </div>
      </div>

      <div class="row">
        <div style="flex:1 1 100%">
          <label>Paquet MWAL (.mwal.json) ou JSON preuve (.json)</label>
          <textarea id="inProof" class="mono" placeholder="Coller le JSON ou importer le fichier"></textarea>
          <input type="file" id="importProof" accept=".json" style="margin-top:8px">
          <input type="file" id="importPackage" accept=".mwal.json,.json" style="margin-top:8px">
          <div class="small">Astuce : importer un <b>paquet MWAL</b> (cl√©+code+preuve) en un seul fichier.</div>
          <div class="btns">
            <button id="btnCheck">üîç V√©rifier</button>
            <button id="btnQuickReceive" class="warn">‚ö° Importer paquet &amp; Recevoir</button>
            <button id="btnAccept" class="warn" disabled>‚úÖ Encaisser</button>
            <button id="btnClear" class="secondary">üßπ Effacer</button>
          </div>
          <div class="status" id="inStatus">Pr√™t.</div>
        </div>
      </div>

      <div class="sep"></div>

      <div class="stats">
        <div class="stat"><div class="lbl">Solde</div><div class="val mono" id="balLbl">0.00000000</div><div class="lbl">MWAL</div></div>
        <div class="stat"><div class="lbl">Encaissements</div><div class="val mono" id="txCountLbl">0</div><div class="lbl">TX</div></div>
      </div>

      <div class="sep"></div>

      <div class="hint">
        Acceptation = coh√©rence <b>cl√©</b> + <b>code chiffr√©</b> + <b>preuve JSON</b> (unit + 4s + hash + total).<br>
        Anti-replay : chaque TX ne peut √™tre encaiss√©e qu'une seule fois.
      </div>
    </div>
  </div>

  <div class="card">
    <div class="hd"><h2>üîÅ Caisse ‚Üí Caisse (POS-mining interne)</h2><span class="tag">OFFLINE</span></div>
    <div class="bd">

      <div class="row">
        <div>
          <label>Adresse destinataire (TO)</label>
          <input id="outTo" class="mono" placeholder="MWAL-POS-XXXXXX ou MWAL-WALLET-XXXXXX">
        </div>
        <div>
          <label>Montant (MWAL) ‚Äî multiple exact de l‚Äôunit√©</label>
          <input id="outAmt" type="number" min="0" step="0.00000001" placeholder="0.00050000">
          <div class="small mono" id="outInfo">‚Äî</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>FROM (nom caisse)</label>
          <input id="outFrom" placeholder="ex: caisse magasin 1">
        </div>
        <div>
          <label>Libell√© (OBLIGATOIRE ‚Äî bien/service)</label>
          <input id="outLabel" placeholder="ex: transfert magasin 1 ‚Üí magasin 2">
        </div>
        <div>
          <label>√âquivalent en euro (‚Ç¨) (suggestion ‚Äî 20 d√©cimales)</label>
          <input id="outEur" class="mono" placeholder="ex: 25.00000000000000000000">
        </div>
      </div>

      <div class="sep"></div>

      <label>Progression POS-mining (bloc X / Y)</label>
      <div class="progress"><div id="posBar"></div></div>
      <div class="small mono" style="margin-top:8px" id="posTxt">0 / 0</div>
      <div class="btns">
        <button id="btnPosStart">‚ñ∂ D√©marrer POS-mining</button>
        <button id="btnPosPause" class="secondary" disabled>‚è∏ Pause</button>
        <button id="btnPosResume" class="secondary" disabled>‚ñ∂ Reprendre</button>
        <button id="btnPosCancel" class="bad" disabled>‚úñ Annuler</button>
      </div>
      <div class="status" id="posStatus">Pr√™t.</div>

      <div class="sep"></div>

      <div class="row">
        <div>
          <label>Cl√© MWAL (√† envoyer)</label>
          <textarea id="outKey" class="mono" readonly></textarea>
          <div class="btns"><button id="btnCopyOutKey" class="secondary" disabled>üìã Copier cl√©</button></div>
        </div>
        <div>
          <label>Code chiffr√© (√† envoyer)</label>
          <textarea id="outCode" class="mono" readonly></textarea>
          <div class="btns"><button id="btnCopyOutCode" class="secondary" disabled>üìã Copier code</button></div>
        </div>
      </div>

      <div class="row">
        <div style="flex:1 1 100%">
          <label>üì¶ JSON preuve (√† envoyer / importer c√¥t√© caisse receveuse)</label>
          <textarea id="outProof" class="mono" readonly></textarea>

          <label style="margin-top:10px">‚õìÔ∏è D√©p√¥t Blockchain OFFLINE (copier/coller dans la Blockchain)</label>
          <textarea id="outChainDeposit" class="mono" readonly></textarea>

          <div class="btns">
            <button id="btnExportOutProof" class="warn" disabled>üì¶ Export PREUVE (.json)</button>
            <button id="btnExportPackage" class="warn" disabled>üì¶ Export PAQUET (.mwal.json)</button>
            <button id="btnExportChainDeposit" class="warn" disabled>‚õìÔ∏è Export D√âP√îT BLOCKCHAIN</button>
            <button id="btnExportObserver" class="warn" disabled>üëÅÔ∏è Export OBSERVATION</button>
            <button id="btnCopyOutProof" class="secondary" disabled>üìã Copier JSON</button>
            <button id="btnCopyChainDeposit" class="secondary" disabled>üìã Copier d√©p√¥t</button>
          </div>
        </div>
      </div>

      <div class="sep"></div>
      <div class="hint"><b>R√®gle POS-mining :</b> on ne recycle jamais les blocs re√ßus. Chaque transfert caisse‚Üícaisse fabrique une nouvelle preuve √† 4s/bloc.</div>
    </div>
  </div>
</div>

<div class="grid2" style="margin-top:12px">
  <div class="card">
    <div class="hd"><h2>üìú Historique</h2><span class="tag">local</span></div>
    <div class="bd"><div class="list" id="hist"></div></div>
  </div>

  <div class="card">
    <div class="hd"><h2>‚öôÔ∏è Param√®tres</h2><span class="tag">coffre-fort</span></div>
    <div class="bd">
      <label>Secret protocole AES-GCM (doit √™tre identique mineur/caisse)</label>
      <input id="secret" class="mono" value="MWAL_CORE_2025_V2_PROTOCOL">

      <div class="sep"></div>

      <label>Identit√© de signature (cl√© publique) ‚Äî <b>COFFRE-FORT</b></label>
      <input id="sigKeyId" class="mono" readonly value="(initialisation‚Ä¶)">
      <div class="small">Restauration/Fusion autoris√©es uniquement si le ledger est sign√© par <b>cette</b> cl√©.</div>
      <div class="btns" style="margin-top:8px">
        <button id="btnExportPubKey" class="secondary">üîì Export cl√© publique (.json)</button>
        <button id="btnRotateKeys" class="bad">üîÅ Rotation cl√©s (dangereux)</button>
      </div>

      <div class="sep"></div>

      <div class="btns">
        <button id="btnExportLedger" class="warn">üì¶ Export ledger caisse (sign√©)</button>
        <button id="btnImportLedger" class="warn">üì• Import ledger caisse</button>
        <button id="btnResetAll" class="bad">üß® Reset caisse</button>
      </div>
      <input type="file" id="importLedger" accept=".json" style="display:none">

      <div class="status" id="sysStatus">Pr√™t.</div>

      <div class="sep"></div>
      <label>Logs</label>
      <textarea id="logs" class="mono" readonly style="min-height:180px"></textarea>
    </div>
  </div>
</div>
</div>

<!-- ===== Modal assistant import ledger ===== -->
<div class="modal-backdrop" id="ledgerModalBackdrop" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modal-hd">
      <h3>üì• Assistant d‚Äôimport Ledger</h3>
      <button class="secondary" id="btnCloseLedgerModal">‚úñ Fermer</button>
    </div>
    <div class="modal-bd">
      <div class="hint">
        Modes :
        <b>Restaurer</b> (√©crase tout), <b>Fusionner</b> (ajoute TX manquantes), <b>Lecture seule</b> (aucune √©criture).
        <br><b>COFFRE-FORT :</b> restaurer/fusionner exigent la <b>m√™me cl√© locale</b>.
        <br><b>Verrou anti-onglets :</b> si une autre instance est active, restauration/fusion sont d√©sactiv√©es ici.
      </div>

      <div class="sep"></div>

      <div class="kv mono" id="ledgerSummaryKv"></div>

      <div class="pillbox" id="ledgerPills"></div>

      <div class="sep"></div>

      <div class="radioRow">
        <label>
          <input type="radio" name="ledgerMode" value="restore" checked>
          <div>
            <div class="mono" style="color:var(--ink2)">Restaurer (overwrite)</div>
            <div class="small">Remplace l‚Äô√©tat local par le ledger import√©.</div>
          </div>
        </label>
        <label>
          <input type="radio" name="ledgerMode" value="merge">
          <div>
            <div class="mono" style="color:var(--ink2)">Fusion intelligente</div>
            <div class="small">Ajoute uniquement les TX absentes + met √† jour solde & anti-replay.</div>
          </div>
        </label>
        <label>
          <input type="radio" name="ledgerMode" value="readonly">
          <div>
            <div class="mono" style="color:var(--ink2)">Lecture seule</div>
            <div class="small">Affiche le ledger (audit) sans modifier la caisse.</div>
          </div>
        </label>
      </div>

      <div class="sep"></div>

      <label>Pr√©visualisation (lecture seule)</label>
      <pre class="codebox mono" id="ledgerPreview"></pre>

      <div class="status" id="ledgerModalStatus">Pr√™t.</div>
    </div>
    <div class="modal-ft">
      <button class="secondary" id="btnLedgerCancel">Annuler</button>
      <button class="warn" id="btnLedgerApply">‚úÖ Appliquer</button>
    </div>
  </div>
</div>

<script>
(() => {
"use strict";

/* ===================== COFFRE-FORT ===================== */
const LEDGER_SAFE_MODE = true; // üîê coffre-fort ON

/* ===================== Instance Lock (ANTI-ONGLETS MULTIPLES) ===================== */
const INSTANCE_ID = (crypto.randomUUID ? crypto.randomUUID() : ("inst-"+Math.random().toString(36).slice(2)));
const INSTANCE_LOCK_KEY = "MWAL_ACTIVE_INSTANCE_LOCK_V1";
const INSTANCE_LOCK_TTL = 8000;     // 8s
const INSTANCE_HEARTBEAT_MS = 3000; // 3s
let instanceHasLock = false;
let instanceHeartbeatTimer = null;
let instanceReclaimTimer = null;

/* ===================== Protocols & constants ===================== */
const PROOF_PROTOCOL="MWAL_MINING_V2";
const TX_PAYLOAD_PROTOCOL="MWAL_TX_PAYLOAD_V2";
const PACKAGE_PROTOCOL="MWAL_PACKAGE_V1";
const LEDGER_PROTOCOL_V3="MWAL_POS_LEDGER_V3"; // legacy
const LEDGER_PROTOCOL_V5="MWAL_POS_LEDGER_V5"; // hash + ECDSA

const UNIT_MWAL_STR="0.00000694444444444444";
const INTERVAL_MS=4000;

const STORE_KEY="mwal_pos_offline_v3";
const POS_ID_KEY="mwal_pos_id_v3";

const SIGN_DB_NAME="mwal_pos_keys_db";
const SIGN_DB_VER=1;
const SIGN_STORE="keys";
const SIGN_KEYPAIR_ID="mwal_signing_keypair_v1";

const $=(id)=>document.getElementById(id);
const logs=$("logs");
const enc=new TextEncoder();

/* ===================== UI helpers ===================== */
function log(msg){
  const t=new Date().toISOString().replace("T"," ").replace("Z","");
  logs.value=`[${t}] ${msg}\n`+logs.value;
}
function setStatus(el,msg,cls){
  el.textContent=msg;
  el.classList.remove("ok","warn","err");
  if(cls) el.classList.add(cls);
}
function round8(n){return Math.round((n+Number.EPSILON)*1e8)/1e8;}
function safeNum(x){const n=Number(x); return Number.isFinite(n)?n:0;}

/* ===================== Instance lock helpers ===================== */
function _readLock(){
  try{ return JSON.parse(localStorage.getItem(INSTANCE_LOCK_KEY)); }catch{ return null; }
}
function acquireInstanceLock(){
  const now = Date.now();
  const lock = _readLock();
  if(lock && lock.id !== INSTANCE_ID && (now - lock.ts) < INSTANCE_LOCK_TTL){
    return false;
  }
  localStorage.setItem(INSTANCE_LOCK_KEY, JSON.stringify({ id: INSTANCE_ID, ts: now }));
  return true;
}
function releaseInstanceLock(){
  try{
    const lock=_readLock();
    if(lock && lock.id === INSTANCE_ID) localStorage.removeItem(INSTANCE_LOCK_KEY);
  }catch{}
}
function startInstanceHeartbeat(){
  stopInstanceHeartbeat();
  instanceHeartbeatTimer = setInterval(()=>{
    if(!instanceHasLock) return;
    localStorage.setItem(INSTANCE_LOCK_KEY, JSON.stringify({ id: INSTANCE_ID, ts: Date.now() }));
  }, INSTANCE_HEARTBEAT_MS);
}
function stopInstanceHeartbeat(){
  if(instanceHeartbeatTimer){ clearInterval(instanceHeartbeatTimer); instanceHeartbeatTimer=null; }
}
function startReclaimLoop(){
  if(instanceReclaimTimer) clearInterval(instanceReclaimTimer);
  instanceReclaimTimer = setInterval(()=>{
    if(instanceHasLock) return;
    const ok = acquireInstanceLock();
    if(ok){
      instanceHasLock = true;
      startInstanceHeartbeat();
      log("üîí Instance lock RECLAIM id="+INSTANCE_ID);
      enforceInstanceLockUI();
    }
  }, 2000);
}
function enforceInstanceLockUI(){
  const disabled = !instanceHasLock;

  // boutons critiques : d√©penses / √©criture / restauration
  [
    "btnAccept","btnPosStart","btnPosPause","btnPosResume","btnPosCancel",
    "btnLedgerApply","btnResetAll","btnRotateKeys"
  ].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.disabled = disabled;
  });

  // si pas de lock, on force aussi un message clair
  if(disabled){
    setStatus($("sysStatus"),
      "üîí Une autre instance de la caisse est active.\nCette instance est en lecture seule (anti-duplication d‚Äôonglets).",
      "warn"
    );
    setStatus($("posStatus"), "üîí Lecture seule : POS-mining bloqu√© (autre onglet actif).", "warn");
  }
}

/* ===================== IDs ===================== */
function getOrCreatePosId(){
  let id=localStorage.getItem(POS_ID_KEY);
  if(id && /^MWAL-POS-[A-Z0-9]{6,12}$/.test(id)) return id;
  const rnd=Math.random().toString(36).slice(2,10).toUpperCase();
  id="MWAL-POS-"+rnd;
  localStorage.setItem(POS_ID_KEY,id);
  return id;
}
function uid(prefix="TX"){
  return `${prefix}-${Date.now().toString(36).toUpperCase()}-${Math.random().toString(36).slice(2,8).toUpperCase()}`;
}

/* ===================== Crypto helpers ===================== */
async function sha256Hex(text){
  const buf=await crypto.subtle.digest("SHA-256", enc.encode(text));
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
}
function b64FromBytes(bytes){let s="";bytes.forEach(b=>s+=String.fromCharCode(b));return btoa(s);}
function bytesFromB64(b64){
  const s=atob(b64); const out=new Uint8Array(s.length);
  for(let i=0;i<s.length;i++) out[i]=s.charCodeAt(i);
  return out;
}
function b64FromArrayBuffer(buf){
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
function arrayBufferFromB64(b64){
  const bin=atob(b64);
  const out=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i);
  return out.buffer;
}
function stableStringify(value){
  const seen=new WeakSet();
  const helper=(v)=>{
    if(v===null || typeof v!=="object") return v;
    if(seen.has(v)) throw new Error("CYCLE");
    seen.add(v);
    if(Array.isArray(v)) return v.map(helper);
    const keys=Object.keys(v).sort();
    const out={};
    for(const k of keys) out[k]=helper(v[k]);
    return out;
  };
  return JSON.stringify(helper(value));
}

/* ===================== AES-GCM (TX payload) ===================== */
async function deriveAesKey(secret){
  const base=await crypto.subtle.importKey("raw", enc.encode(secret), {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    {name:"PBKDF2",salt:enc.encode("MWAL_SALT_V2"),iterations:100000,hash:"SHA-256"},
    base,{name:"AES-GCM",length:256},false,["encrypt","decrypt"]
  );
}
async function decryptJson(secret,packed){
  const parts=String(packed||"").split("|");
  if(parts.length!==3 || parts[0]!=="MWAL-AESGCM") throw new Error("BAD_CODE");
  const iv=bytesFromB64(parts[1]);
  const ct=bytesFromB64(parts[2]);
  const key=await deriveAesKey(secret);
  const ptBuf=await crypto.subtle.decrypt({name:"AES-GCM",iv},key,ct);
  return JSON.parse(new TextDecoder().decode(ptBuf));
}
async function encryptJson(secret,obj){
  const key=await deriveAesKey(secret);
  const iv=crypto.getRandomValues(new Uint8Array(12));
  const plaintext=enc.encode(JSON.stringify(obj));
  const ct=new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv},key,plaintext));
  return "MWAL-AESGCM|"+b64FromBytes(iv)+"|"+b64FromBytes(ct);
}

/* ===================== IndexedDB for CryptoKeyPair ===================== */
function openSignDb(){
  return new Promise((resolve,reject)=>{
    const req=indexedDB.open(SIGN_DB_NAME, SIGN_DB_VER);
    req.onupgradeneeded=()=>{
      const db=req.result;
      if(!db.objectStoreNames.contains(SIGN_STORE)) db.createObjectStore(SIGN_STORE);
    };
    req.onsuccess=()=>resolve(req.result);
    req.onerror=()=>reject(req.error);
  });
}
async function idbGet(key){
  const db=await openSignDb();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(SIGN_STORE,"readonly");
    const store=tx.objectStore(SIGN_STORE);
    const req=store.get(key);
    req.onsuccess=()=>resolve(req.result||null);
    req.onerror=()=>reject(req.error);
  });
}
async function idbSet(key, val){
  const db=await openSignDb();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(SIGN_STORE,"readwrite");
    const store=tx.objectStore(SIGN_STORE);
    const req=store.put(val, key);
    req.onsuccess=()=>resolve(true);
    req.onerror=()=>reject(req.error);
  });
}
async function idbDel(key){
  const db=await openSignDb();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(SIGN_STORE,"readwrite");
    const store=tx.objectStore(SIGN_STORE);
    const req=store.delete(key);
    req.onsuccess=()=>resolve(true);
    req.onerror=()=>reject(req.error);
  });
}

/* ===================== Asymmetric signing (ECDSA P-256) ===================== */
async function getOrCreateSigningKeyPair(){
  let kp = await idbGet(SIGN_KEYPAIR_ID);
  if(kp && kp.privateKey && kp.publicKey) return kp;
  kp = await crypto.subtle.generateKey(
    { name:"ECDSA", namedCurve:"P-256" },
    false,
    ["sign","verify"]
  );
  await idbSet(SIGN_KEYPAIR_ID, kp);
  return kp;
}
async function exportPublicJwk(){
  const kp=await getOrCreateSigningKeyPair();
  return crypto.subtle.exportKey("jwk", kp.publicKey);
}
async function computeKeyIdFromJwk(jwk){
  return sha256Hex(stableStringify(jwk));
}
async function signLedgerHashAsym(ledgerHash){
  const kp=await getOrCreateSigningKeyPair();
  const msg = enc.encode("MWAL_LEDGER_V5|" + ledgerHash);
  const sig = await crypto.subtle.sign({ name:"ECDSA", hash:"SHA-256" }, kp.privateKey, msg);
  return b64FromArrayBuffer(sig);
}
async function verifyLedgerHashAsym(ledgerHash, sigB64, pubJwk){
  try{
    const pubKey = await crypto.subtle.importKey(
      "jwk", pubJwk, { name:"ECDSA", namedCurve:"P-256" }, true, ["verify"]
    );
    const msg = enc.encode("MWAL_LEDGER_V5|" + ledgerHash);
    const sigBuf = arrayBufferFromB64(sigB64);
    return crypto.subtle.verify({ name:"ECDSA", hash:"SHA-256" }, pubKey, sigBuf, msg);
  }catch{ return false; }
}

/* ===================== MWAL Key parsing & proof validation ===================== */
function parseKey(key){
  const out={};
  const parts=String(key||"").trim().split("|");
  if(parts[0]!=="MWAL") return null;
  for(const p of parts.slice(1)){
    const i=p.indexOf("=");
    if(i<0) continue;
    out[p.slice(0,i)] = p.slice(i+1);
  }
  if(!out.TX || !out.TO || !out.AMOUNT) return null;
  out.FROM = out.FROM ? decodeURIComponent(out.FROM) : "‚Äî";
  out.LABEL = out.LABEL ? decodeURIComponent(out.LABEL) : "";
  out.TS = out.TS ? decodeURIComponent(out.TS) : "";
  return out;
}
async function validateProof(proof, expected){
  if(!proof || typeof proof!=="object") return {ok:false,err:"JSON invalide"};
  if(proof.protocol!==PROOF_PROTOCOL) return {ok:false,err:"BAD_PROTOCOL"};
  if(proof.txId!==expected.txId) return {ok:false,err:"TX mismatch"};
  if(proof.to!==expected.to) return {ok:false,err:"TO mismatch"};
  if(!proof.rules || proof.rules.unitMWAL!==UNIT_MWAL_STR || proof.rules.intervalMs!==INTERVAL_MS) return {ok:false,err:"Rules mismatch"};
  const blocks=Array.isArray(proof.blocks)?proof.blocks:[];
  if(blocks.length===0) return {ok:false,err:"No blocks"};

  let prev="GENESIS";
  for(let i=0;i<blocks.length;i++){
    const b=blocks[i];
    if(String(b.amountMWAL)!==UNIT_MWAL_STR) return {ok:false,err:"Bad unit"};
    if(b.prevHash!==prev) return {ok:false,err:"Chain broken"};
    if(i>0){
      const t0=Date.parse(blocks[i-1].timestamp);
      const t1=Date.parse(b.timestamp);
      if(!Number.isFinite(t0)||!Number.isFinite(t1)) return {ok:false,err:"Bad timestamp"};
      if((t1-t0)!==INTERVAL_MS) return {ok:false,err:"Interval != 4s"};
    }
    const copy=Object.assign({},b); delete copy.hash;
    const h=await sha256Hex(JSON.stringify(copy));
    if(h!==b.hash) return {ok:false,err:"Bad hash"};
    prev=b.hash;
  }
  if(proof.finalHash && proof.finalHash!==prev) return {ok:false,err:"Final hash mismatch"};
  const provedAmount=round8(blocks.length*Number(UNIT_MWAL_STR));
  const expAmount=Number(expected.amountMWAL);
  if(Math.abs(provedAmount-expAmount)>1e-8) return {ok:false,err:"Amount mismatch"};
  return {ok:true, provedAmount};
}

/* ===================== State ===================== */
const defaultState=() => ({
  posId:getOrCreatePosId(),
  balance:0,
  accepted:[],
  consumedTx:{},
  lastCheck:null,
  posMining:null,
  lastOutgoing:null
});
let S=null;
function load(){
  try{
    const raw=localStorage.getItem(STORE_KEY);
    if(!raw){ S=defaultState(); save(); return; }
    S=Object.assign(defaultState(), JSON.parse(raw));
    S.posId=getOrCreatePosId();
    save();
  }catch{
    S=defaultState(); save();
  }
}
function save(){ localStorage.setItem(STORE_KEY, JSON.stringify(S)); }

/* ===================== Render ===================== */
function renderHeader(){ $("posIdLbl").textContent=S.posId; }
function renderStats(){
  $("balLbl").textContent=round8(S.balance).toFixed(8);
  $("txCountLbl").textContent=String(S.accepted.length);
}
function renderHist(){
  const box=$("hist"); box.innerHTML="";
  if(!S.accepted.length){
    box.innerHTML='<div class="small">Aucun encaissement.</div>';
    return;
  }
  const view=S.accepted.slice().reverse().slice(0,60);
  for(const tx of view){
    const div=document.createElement("div");
    div.className="item mono";
    div.innerHTML=`<b>${tx.txId}</b><br/>from: ${tx.from}<br/>amount: ${Number(tx.amountMWAL).toFixed(8)} MWAL<br/><span class="small">proofHash: ${(String(tx.proofHash||"").slice(0,18))}‚Ä¶ ‚Ä¢ ${tx.ts}</span>`;
    box.appendChild(div);
  }
}

/* ===================== Encaissement ===================== */
function clearInputs(){
  $("inKey").value=""; $("inCode").value=""; $("inProof").value="";
  $("btnAccept").disabled=true;
  S.lastCheck=null; save();
  setStatus($("inStatus"),"Pr√™t.","");
}
async function check(){
  try{
    const keyRaw=$("inKey").value.trim();
    const codeRaw=$("inCode").value.trim();
    const proofRaw=$("inProof").value.trim();
    if(!keyRaw||!codeRaw||!proofRaw){ setStatus($("inStatus"),"‚ùå Il faut : cl√© + code + JSON.","err"); return; }

    const k=parseKey(keyRaw);
    if(!k){ setStatus($("inStatus"),"‚ùå Cl√© MWAL invalide.","err"); return; }
    if(k.TO!==S.posId){ setStatus($("inStatus"),`‚ùå TO ‚â† cette caisse (${S.posId}).`,"err"); return; }
    if(S.consumedTx[k.TX]){ setStatus($("inStatus"),"‚ùå TX d√©j√† encaiss√©e (replay).","err"); return; }

    let proof;
    try{ proof=JSON.parse(proofRaw); }catch{ setStatus($("inStatus"),"‚ùå JSON blocs invalide.","err"); return; }

    const vProof=await validateProof(proof,{txId:k.TX,to:k.TO,amountMWAL:k.AMOUNT,from:k.FROM});
    if(!vProof.ok){ setStatus($("inStatus"),"‚ùå Preuve invalide : "+vProof.err,"err"); return; }

    const secret=$("secret").value.trim() || "MWAL_CORE_2025_V2_PROTOCOL";
    let payload;
    try{ payload=await decryptJson(secret,codeRaw); }catch{ setStatus($("inStatus"),"‚ùå Code chiffr√© illisible (secret ?).","err"); return; }

    if(payload.protocol!==TX_PAYLOAD_PROTOCOL){ setStatus($("inStatus"),"‚ùå Mauvais protocole payload.","err"); return; }
    if(payload.txId!==k.TX || payload.to!==k.TO){ setStatus($("inStatus"),"‚ùå Incoh√©rence code ‚Üî cl√©.","err"); return; }
    if(String(payload.amountMWAL)!==String(k.AMOUNT)){ setStatus($("inStatus"),"‚ùå Montant code ‚Üî cl√© diff√©rent.","err"); return; }

    const proofHash=await sha256Hex(JSON.stringify(proof));
    if(payload.proofHash!==proofHash){ setStatus($("inStatus"),"‚ùå proofHash mismatch (code ‚Üî JSON).","err"); return; }

    S.lastCheck={ok:true,txId:k.TX,from:k.FROM,to:k.TO,amountMWAL:Number(k.AMOUNT),ts:k.TS||new Date().toISOString(),proofHash,key:keyRaw,code:codeRaw,proof};
    save();
    $("btnAccept").disabled=!instanceHasLock; // verrou d‚Äôinstance
    setStatus($("inStatus"), instanceHasLock ? "‚úÖ V√©rification OK. Tu peux encaisser." : "üîí V√©rification OK, mais lecture seule (autre onglet actif).", instanceHasLock ? "ok" : "warn");
    log("‚úÖ CHECK OK tx="+k.TX+" amount="+k.AMOUNT);
  }catch(e){
    setStatus($("inStatus"),"‚ùå Erreur interne: "+(e&&e.message?e.message:String(e)),"err");
  }
}
function accept(){
  if(!instanceHasLock){
    setStatus($("inStatus"),"üîí Lecture seule : encaissement bloqu√© (autre onglet actif).","warn");
    return;
  }
  if(!S.lastCheck||!S.lastCheck.ok){ setStatus($("inStatus"),"‚ùå Rien √† encaisser.","err"); return; }
  const t=S.lastCheck;
  S.balance=round8(S.balance+Number(t.amountMWAL));
  S.accepted.push({txId:t.txId,from:t.from,to:t.to,amountMWAL:t.amountMWAL,ts:t.ts,proofHash:t.proofHash,codeOk:true});
  S.consumedTx[t.txId]=true;
  S.lastCheck=null;
  save();
  renderStats(); renderHist();
  $("btnAccept").disabled=true;
  setStatus($("inStatus"),"‚úÖ Encaissement enregistr√©.","ok");
  log("üí∞ ACCEPT tx="+t.txId+" +"+t.amountMWAL.toFixed(8));
}

/* ===================== POS Mining / Outgoing ===================== */
function computeTargetBlocks(amountMWAL){
  if(!(amountMWAL>0)) return 0;
  const exact=amountMWAL/Number(UNIT_MWAL_STR);
  const n=Math.round(exact);
  return (Math.abs(exact-n)<1e-9) ? n : 0;
}
function updateOutInfo(){
  const amt=Number($("outAmt").value||0);
  if(!amt){ $("outInfo").textContent="‚Äî"; return; }
  const n=computeTargetBlocks(amt);
  if(n<=0){
    const floorN=Math.floor(amt/Number(UNIT_MWAL_STR));
    const proved=floorN*Number(UNIT_MWAL_STR);
    const rem=amt-proved;
    $("outInfo").textContent=`‚ùå Non multiple exact. blocs possibles=${floorN} (= ${round8(proved).toFixed(8)}), reste=${round8(rem).toFixed(8)}`;
    return;
  }
  $("outInfo").textContent=`‚úÖ ${n} bloc(s) ‚Üí ~${n*4}s`;
}

let posTimer=null;
function clearPosTimer(){ if(posTimer){ clearTimeout(posTimer); posTimer=null; } }

async function makeBlock(prevHash,index,tsIso,txId){
  const block={index,timestamp:tsIso,walletId:S.posId,txId,amountMWAL:UNIT_MWAL_STR,prevHash,nonce:crypto.getRandomValues(new Uint32Array(1))[0]};
  block.hash=await sha256Hex(JSON.stringify(block));
  return block;
}
function updatePosUI(){
  const m=S.posMining;
  const bar=$("posBar"); const txt=$("posTxt");
  if(!m){
    bar.style.width="0%"; txt.textContent="0 / 0";
    $("btnPosPause").disabled=true; $("btnPosResume").disabled=true; $("btnPosCancel").disabled=true;
    return;
  }
  const pct=m.targetBlocks?Math.min(100,(m.doneBlocks/m.targetBlocks)*100):0;
  bar.style.width=pct.toFixed(1)+"%";
  txt.textContent=`${m.doneBlocks} / ${m.targetBlocks}`;
  $("btnPosPause").disabled=(!instanceHasLock || m.status!=="RUNNING");
  $("btnPosResume").disabled=(!instanceHasLock || m.status!=="PAUSED");
  $("btnPosCancel").disabled=(!instanceHasLock || (m.status!=="RUNNING" && m.status!=="PAUSED"));
}
async function posTick(){
  const m=S.posMining;
  if(!m||m.status!=="RUNNING") return;
  const idx=m.doneBlocks;
  const prevHash=(idx===0)?"GENESIS":m.blocks[idx-1].hash;
  const canonTs=new Date(m.startTimeMs+idx*INTERVAL_MS).toISOString();
  const blk=await makeBlock(prevHash,idx,canonTs,m.txId);
  m.blocks.push(blk); m.doneBlocks+=1; save();
  updatePosUI();
  setStatus($("posStatus"),`‚õèÔ∏è POS-mining bloc ${m.doneBlocks}/${m.targetBlocks}`,"ok");
  if(m.doneBlocks>=m.targetBlocks){
    m.status="DONE"; save(); clearPosTimer();
    await finalizeOutgoing();
    updatePosUI();
    setStatus($("posStatus"),"‚úÖ POS-mining termin√©. Paquet pr√™t.","ok");
    log("‚úÖ POS DONE tx="+m.txId);
    return;
  }
  clearPosTimer();
  posTimer=setTimeout(()=>posTick(),INTERVAL_MS);
}
function validatePosInputs(){
  const to=$("outTo").value.trim();
  const from=$("outFrom").value.trim()||"caisse";
  const label=$("outLabel").value.trim();
  const amount=Number($("outAmt").value||0);
  if(!/^MWAL-(POS|WALLET)-[A-Z0-9]{6,12}$/.test(to)) return {ok:false,err:"Adresse destinataire invalide (MWAL-POS-... ou MWAL-WALLET-...)."};
  if(!(amount>0)) return {ok:false,err:"Montant invalide."};
  if(!label) return {ok:false,err:"Libell√© obligatoire (bien/service)."};
  if(amount>S.balance+1e-12) return {ok:false,err:"Solde insuffisant."};
  const n=computeTargetBlocks(amount);
  if(n<=0) return {ok:false,err:"Montant non multiple exact de l‚Äôunit√©."};
  return {ok:true,to,from,label,amount,blocks:n};
}
async function posStart(){
  if(!instanceHasLock){
    setStatus($("posStatus"),"üîí Lecture seule : POS-mining bloqu√© (autre onglet actif).","warn");
    return;
  }
  if(S.posMining && (S.posMining.status==="RUNNING"||S.posMining.status==="PAUSED")){
    setStatus($("posStatus"),"‚ö†Ô∏è POS d√©j√† en cours.","warn"); return;
  }
  const v=validatePosInputs();
  if(!v.ok){ setStatus($("posStatus"),"‚ùå "+v.err,"err"); return; }

  $("outKey").value=""; $("outCode").value=""; $("outProof").value=""; $("outChainDeposit").value="";
  $("btnCopyOutKey").disabled=true; $("btnCopyOutCode").disabled=true;
  $("btnExportOutProof").disabled=true; $("btnExportPackage").disabled=true; $("btnExportChainDeposit").disabled=true; $("btnExportObserver").disabled=true;
  $("btnCopyOutProof").disabled=true; $("btnCopyChainDeposit").disabled=true;

  const txId=uid("TX");
  S.posMining={
    protocol:PROOF_PROTOCOL,txId,walletId:S.posId,rules:{unitMWAL:UNIT_MWAL_STR,intervalMs:INTERVAL_MS},
    to:v.to,from:v.from,label:v.label,amountMWAL:round8(v.amount),
    targetBlocks:v.blocks,doneBlocks:0,blocks:[],status:"RUNNING",createdAt:new Date().toISOString(),startTimeMs:Date.now()
  };
  S.lastOutgoing=null; save();
  updatePosUI();
  setStatus($("posStatus"),`‚õèÔ∏è POS-mining d√©marr√© : ${v.blocks} blocs (~${v.blocks*4}s).`,"ok");
  log("‚õèÔ∏è POS START tx="+txId+" to="+v.to+" amount="+v.amount.toFixed(8));
  clearPosTimer();
  posTimer=setTimeout(()=>posTick(),20);
}
function posPause(){ if(!instanceHasLock) return; if(!S.posMining||S.posMining.status!=="RUNNING")return; S.posMining.status="PAUSED"; save(); clearPosTimer(); updatePosUI(); setStatus($("posStatus"),"‚è∏ Pause.","warn"); }
function posResume(){ if(!instanceHasLock) return; if(!S.posMining||S.posMining.status!=="PAUSED")return; S.posMining.status="RUNNING"; save(); updatePosUI(); setStatus($("posStatus"),"‚ñ∂ Reprise.","ok"); clearPosTimer(); posTimer=setTimeout(()=>posTick(),20); }
function posCancel(){ if(!instanceHasLock) return; if(!S.posMining||(S.posMining.status!=="RUNNING"&&S.posMining.status!=="PAUSED"))return; if(!confirm("Annuler POS-mining ?"))return; S.posMining=null; save(); clearPosTimer(); updatePosUI(); setStatus($("posStatus"),"‚úñ Annul√©.","warn"); }

async function finalizeOutgoing(){
  const m=S.posMining;
  if(!m||m.status!=="DONE") return;

  const amountMWAL=round8(m.targetBlocks*Number(UNIT_MWAL_STR));
  const key=["MWAL","TX="+m.txId,"FROM="+encodeURIComponent(m.from),"TO="+m.to,"AMOUNT="+amountMWAL.toFixed(8),"TS="+encodeURIComponent(m.createdAt),
    m.label?("LABEL="+encodeURIComponent(m.label)):""].filter(Boolean).join("|");

  const proof={protocol:PROOF_PROTOCOL,walletId:m.walletId,txId:m.txId,rules:{unitMWAL:UNIT_MWAL_STR,intervalMs:INTERVAL_MS},to:m.to,from:m.from,label:m.label||"",
    createdAt:m.createdAt,blocks:m.blocks,finalHash:m.blocks.length?m.blocks[m.blocks.length-1].hash:"0"};

  const secret=$("secret").value.trim() || "MWAL_CORE_2025_V2_PROTOCOL";
  const proofHash=await sha256Hex(JSON.stringify(proof));
  const payload={protocol:TX_PAYLOAD_PROTOCOL,txId:m.txId,from:m.from,to:m.to,amountMWAL:amountMWAL.toFixed(8),createdAt:m.createdAt,label:m.label||"",proofHash};
  const code=await encryptJson(secret,payload);

  S.lastOutgoing={key,code,proof}; save();
  $("outKey").value=key; $("outCode").value=code; $("outProof").value=JSON.stringify(proof,null,2);
  $("btnCopyOutKey").disabled=false; $("btnCopyOutCode").disabled=false;
  $("btnExportOutProof").disabled=false; $("btnExportPackage").disabled=false; $("btnExportObserver").disabled=false; $("btnCopyOutProof").disabled=false;

  const pkg={protocol:PACKAGE_PROTOCOL,key:S.lastOutgoing.key,code:S.lastOutgoing.code,proof:S.lastOutgoing.proof,createdAt:new Date().toISOString()};
  const eurHintRaw=String(($("outEur")&&$("outEur").value)||"").trim();
  const eurHint=(eurHintRaw && /^-?\d+(\.\d+)?$/.test(eurHintRaw)) ? eurHintRaw : "";
  const amount20=(amountMWAL.toFixed(8) + "00000000000000000000").replace(/(\d+\.\d{20}).*/, "$1");
  const chainDeposit={
    protocol:"MWAL_CHAIN_DEPOSIT_V1",
    origin:"CAISSE",
    depositId:"DEP-"+m.txId,
    receivedAt:Date.now(),
    status:"LOCKED",
    payload:Object.assign({},pkg,{asset:"MWAL",amount:String(amount20),label:m.label,finalTo:m.to,eurHint: eurHint || undefined})
  };
  $("outChainDeposit").value=JSON.stringify(chainDeposit,null,2);
  $("btnExportChainDeposit").disabled=false;
  $("btnCopyChainDeposit").disabled=false;

  // d√©bit imm√©diat
  S.balance=round8(S.balance-amountMWAL);
  save();
  renderStats(); renderHist();
  setStatus($("sysStatus"),"‚úÖ Transfert pr√™t. Export le d√©p√¥t blockchain et colle-le dans la Blockchain OFFLINE (t√©moin).","ok");
  log("‚û°Ô∏è OUT READY tx="+m.txId+" -"+amountMWAL.toFixed(8));
  S.posMining=Object.assign({},m,{status:"ARCHIVED"}); save();
}

/* ===================== Download/copy ===================== */
function downloadJson(obj,filename){
  const json=JSON.stringify(obj,null,2);
  const blob=new Blob([json],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download=filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
async function copyText(text){
  if(!text) return false;
  try{ await navigator.clipboard.writeText(text); return true; }catch{ return false; }
}

/* ===================== Ledger V5 (hash + signature asym) ===================== */
async function buildLedgerV5(){
  const pubJwk = await exportPublicJwk();
  const keyId = await computeKeyIdFromJwk(pubJwk);

  const base={
    protocol: LEDGER_PROTOCOL_V5,
    posId: S.posId,
    balanceMWAL: round8(S.balance).toFixed(8),
    accepted: S.accepted,
    exportedAt: new Date().toISOString(),
    signer: { alg:"ECDSA_P256_SHA256", keyId, pubJwk }
  };

  const canonical = {
    protocol: base.protocol,
    posId: base.posId,
    balanceMWAL: base.balanceMWAL,
    accepted: base.accepted,
    exportedAt: base.exportedAt,
    signer: base.signer
  };

  const ledgerHash = await sha256Hex(stableStringify(canonical));
  const ledgerSigAsym = await signLedgerHashAsym(ledgerHash);

  return Object.assign({}, base, { ledgerHash, ledgerSigAsym });
}
async function exportLedger(){
  const data = await buildLedgerV5();
  downloadJson(data, `MWAL_POS_LEDGER_${S.posId}.json`);
  setStatus($("sysStatus"),"‚úÖ Ledger export√© (V5 sign√© ECDSA).","ok");
  log("üì¶ LEDGER EXPORT v5 pos="+S.posId+" keyId="+data.signer.keyId.slice(0,12));
}

/* ===================== Import ledger assistant ===================== */
let importedLedgerCtx=null;

function showLedgerModal(show){
  $("ledgerModalBackdrop").style.display = show ? "flex" : "none";
}
function modalSetStatus(msg,cls){ setStatus($("ledgerModalStatus"), msg, cls); }
function makePill(text, cls){
  const el=document.createElement("div");
  el.className="pilltag " + (cls||"");
  el.textContent=text;
  return el;
}
function summarizeLedgerKv(info){
  const kv=$("ledgerSummaryKv");
  kv.innerHTML="";
  const row=(k,v)=>{
    const kEl=document.createElement("div"); kEl.className="k"; kEl.textContent=k;
    const vEl=document.createElement("div"); vEl.className="v mono"; vEl.textContent=v;
    kv.appendChild(kEl); kv.appendChild(vEl);
  };
  row("Fichier", info.filename || "‚Äî");
  row("Protocol", info.protocol || "‚Äî");
  row("posId", info.posId || "‚Äî");
  row("balance", info.balanceMWAL || "‚Äî");
  row("accepted", String(info.txCount||0));
  row("exportedAt", info.exportedAt || "‚Äî");
  row("ledgerHash", info.ledgerHash ? (info.ledgerHash.slice(0,18)+"‚Ä¶") : "‚Äî");
  row("sig", info.sig ? (info.sig.slice(0,18)+"‚Ä¶") : "‚Äî");
  row("signerKeyId", info.signerKeyId ? (info.signerKeyId.slice(0,18)+"‚Ä¶") : "‚Äî");
}

async function parseAndVerifyLedger(rawObj){
  const protocol = rawObj && rawObj.protocol;
  if(protocol !== LEDGER_PROTOCOL_V3 && protocol !== LEDGER_PROTOCOL_V5){
    return { ok:false, err:"Protocole ledger non support√© (V3/V5)." };
  }
  if(!rawObj.posId || !/^MWAL-POS-[A-Z0-9]{6,12}$/.test(rawObj.posId)){
    return { ok:false, err:"posId invalide dans le ledger." };
  }
  if(!Array.isArray(rawObj.accepted)) return { ok:false, err:"Champ accepted invalide." };

  const accepted = rawObj.accepted.map(t => ({
    txId: String(t.txId||""),
    from: String(t.from||"‚Äî"),
    to: String(t.to||rawObj.posId||""),
    amountMWAL: safeNum(t.amountMWAL),
    ts: String(t.ts||""),
    proofHash: String(t.proofHash||""),
    codeOk: !!t.codeOk
  })).filter(t => t.txId);

  const normalized = {
    protocol,
    posId: rawObj.posId,
    balanceMWAL: String(rawObj.balanceMWAL ?? "0.00000000"),
    accepted,
    exportedAt: String(rawObj.exportedAt||""),
    signer: rawObj.signer || null,
    ledgerHash: rawObj.ledgerHash ? String(rawObj.ledgerHash) : "",
    ledgerSigAsym: rawObj.ledgerSigAsym ? String(rawObj.ledgerSigAsym) : ""
  };

  let computedHash="", hashOk=null, sigAsymOk=null;

  if(protocol === LEDGER_PROTOCOL_V5){
    const canonical = {
      protocol: normalized.protocol,
      posId: normalized.posId,
      balanceMWAL: normalized.balanceMWAL,
      accepted: normalized.accepted,
      exportedAt: normalized.exportedAt,
      signer: normalized.signer
    };
    computedHash = await sha256Hex(stableStringify(canonical));
    hashOk = (normalized.ledgerHash && normalized.ledgerHash === computedHash);

    const pubJwk = normalized.signer && normalized.signer.pubJwk;
    if(pubJwk && normalized.ledgerSigAsym && normalized.ledgerHash){
      sigAsymOk = await verifyLedgerHashAsym(normalized.ledgerHash, normalized.ledgerSigAsym, pubJwk);
    }else{
      sigAsymOk = false;
    }
  }

  return { ok:true, normalized, verify:{ computedHash, hashOk, sigAsymOk } };
}

function getSelectedLedgerMode(){
  const radios = document.querySelectorAll('input[name="ledgerMode"]');
  for(const r of radios) if(r.checked) return r.value;
  return "restore";
}
function applyLedgerRestore(ledger){
  const consumedTx = {};
  for(const tx of ledger.accepted) consumedTx[tx.txId]=true;

  const nextState = {
    posId: ledger.posId,
    balance: safeNum(ledger.balanceMWAL),
    accepted: ledger.accepted,
    consumedTx,
    lastCheck: null,
    posMining: null,
    lastOutgoing: null
  };

  localStorage.setItem(STORE_KEY, JSON.stringify(nextState));
  localStorage.setItem(POS_ID_KEY, ledger.posId);
}
function applyLedgerMerge(ledger){
  const existingConsumed = S.consumedTx || {};
  const added = [];
  for(const tx of ledger.accepted){
    if(!existingConsumed[tx.txId]) added.push(tx);
  }
  if(!added.length) return { addedCount:0, addedAmount:0 };
  const addAmount = round8(added.reduce((acc,t)=>acc + safeNum(t.amountMWAL),0));
  S.balance = round8(S.balance + addAmount);
  for(const tx of added){
    S.accepted.push(tx);
    S.consumedTx[tx.txId]=true;
  }
  save();
  return { addedCount: added.length, addedAmount: addAmount };
}

function openLedgerAssistant(file, obj, parsed){
  importedLedgerCtx = { file, obj, parsed };
  const ledger = parsed.normalized;
  const ver = parsed.verify;

  summarizeLedgerKv({
    filename: file ? file.name : "‚Äî",
    protocol: ledger.protocol,
    posId: ledger.posId,
    balanceMWAL: ledger.balanceMWAL,
    txCount: ledger.accepted.length,
    exportedAt: ledger.exportedAt || "‚Äî",
    ledgerHash: ledger.ledgerHash || "",
    sig: ledger.ledgerSigAsym || "",
    signerKeyId: ledger.signer && ledger.signer.keyId ? ledger.signer.keyId : ""
  });

  const pills = $("ledgerPills");
  pills.innerHTML="";

  if(ledger.protocol === LEDGER_PROTOCOL_V5){
    pills.appendChild(makePill("Ledger V5", "ok"));
    pills.appendChild(makePill(ver.hashOk ? "Hash OK" : "Hash mismatch", ver.hashOk ? "ok":"err"));
    pills.appendChild(makePill(ver.sigAsymOk ? "Signature ECDSA OK" : "Signature ECDSA invalide", ver.sigAsymOk ? "ok":"err"));

    const localKeyId = $("sigKeyId").value || "";
    const ledgerKeyId = ledger.signer && ledger.signer.keyId ? ledger.signer.keyId : "";
    if(localKeyId && ledgerKeyId){
      if(localKeyId === ledgerKeyId) pills.appendChild(makePill("Sign√© par CETTE caisse", "ok"));
      else pills.appendChild(makePill("Sign√© par une autre caisse", "warn"));
    }

    if(LEDGER_SAFE_MODE) pills.appendChild(makePill("Coffre-fort ON", "ok"));
  }else{
    pills.appendChild(makePill("Ledger V3 (ancien)", "warn"));
    pills.appendChild(makePill("Pas de signature ECDSA", "warn"));
  }

  if(!instanceHasLock){
    pills.appendChild(makePill("Lecture seule (autre onglet actif)", "warn"));
  }

  $("ledgerPreview").textContent = JSON.stringify(obj, null, 2).slice(0, 50000);
  document.querySelector('input[name="ledgerMode"][value="restore"]').checked = true;

  modalSetStatus("Pr√™t. Choisis un mode puis ‚ÄúAppliquer‚Äù.", "");
  showLedgerModal(true);

  // applique imm√©diatement l‚ÄôUI lock (d√©sactive Appliquer si besoin)
  enforceInstanceLockUI();
}

function importLedgerFile(file){
  const r=new FileReader();
  r.onload = async () => {
    try{
      const txt = String(r.result||"").trim();
      const obj = JSON.parse(txt);
      modalSetStatus("‚è≥ Analyse du ledger‚Ä¶","warn");

      const parsed = await parseAndVerifyLedger(obj);
      if(!parsed.ok){
        alert("‚ùå Ledger invalide :\n" + parsed.err);
        return;
      }
      openLedgerAssistant(file, obj, parsed);
      log("üì• LEDGER LOADED file="+file.name);
    }catch(e){
      alert("‚ùå Import ledger impossible :\n" + (e&&e.message?e.message:String(e)));
    }
  };
  r.readAsText(file);
}

/* ===================== Reset ===================== */
function resetAll(){
  if(!instanceHasLock){
    setStatus($("sysStatus"),"üîí Lecture seule : reset bloqu√© (autre onglet actif).","warn");
    return;
  }
  if(!confirm("Reset caisse ?")) return;
  localStorage.removeItem(STORE_KEY);
  localStorage.removeItem(POS_ID_KEY);
  location.reload();
}

/* ===================== Wire UI ===================== */
function wire(){
  $("btnCopyPos").addEventListener("click",async()=>{
    const ok=await copyText(S.posId);
    setStatus($("sysStatus"), ok?"‚úÖ ID caisse copi√©.":"‚ùå Copie impossible.", ok?"ok":"err");
  });

  $("btnQuickReceive").addEventListener("click",()=>{
    const inp=$("importPackage");
    inp.value="";
    inp.click();
  });

  $("importPackage").addEventListener("change",(e)=>{
    const file=e.target.files&&e.target.files[0];
    if(!file) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const txt=String(r.result||"").trim();
        const obj=JSON.parse(txt);
        if(!obj || obj.protocol!==PACKAGE_PROTOCOL) throw new Error("BAD_PACKAGE");
        if(!obj.key || !obj.code || !obj.proof) throw new Error("INCOMPLETE_PACKAGE");
        $("inKey").value=String(obj.key);
        $("inCode").value=String(obj.code);
        $("inProof").value=JSON.stringify(obj.proof,null,2);
        setStatus($("inStatus"),"‚úÖ Paquet MWAL import√©. V√©rification automatique‚Ä¶","warn");
        check().then(()=>{ if(!$("btnAccept").disabled) accept(); });
      }catch{
        setStatus($("inStatus"),"‚ùå Paquet MWAL invalide.","err");
      }
    };
    r.readAsText(file);
  });

  $("importProof").addEventListener("change",(e)=>{
    const file=e.target.files&&e.target.files[0];
    if(!file) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const txt=String(r.result||"").trim();
        JSON.parse(txt);
        $("inProof").value=txt;
        setStatus($("inStatus"),"‚úÖ JSON import√©. Clique ‚ÄúV√©rifier‚Äù.","ok");
      }catch{
        setStatus($("inStatus"),"‚ùå JSON invalide.","err");
      }
    };
    r.readAsText(file);
  });

  $("btnCheck").addEventListener("click",check);
  $("btnAccept").addEventListener("click",accept);
  $("btnClear").addEventListener("click",clearInputs);

  $("outAmt").addEventListener("input",updateOutInfo);
  $("btnPosStart").addEventListener("click",posStart);
  $("btnPosPause").addEventListener("click",posPause);
  $("btnPosResume").addEventListener("click",posResume);
  $("btnPosCancel").addEventListener("click",posCancel);

  $("btnCopyOutKey").addEventListener("click",async()=>{
    const ok=await copyText($("outKey").value);
    setStatus($("posStatus"), ok?"‚úÖ Cl√© copi√©e.":"‚ùå Copie impossible.", ok?"ok":"err");
  });
  $("btnCopyOutCode").addEventListener("click",async()=>{
    const ok=await copyText($("outCode").value);
    setStatus($("posStatus"), ok?"‚úÖ Code copi√©.":"‚ùå Copie impossible.", ok?"ok":"err");
  });
  $("btnCopyOutProof").addEventListener("click",async()=>{
    const ok=await copyText($("outProof").value);
    setStatus($("posStatus"), ok?"‚úÖ JSON copi√©.":"‚ùå Copie impossible.", ok?"ok":"err");
  });

  $("btnExportOutProof").addEventListener("click",()=>{
    if(!S.lastOutgoing||!S.lastOutgoing.proof){ setStatus($("posStatus"),"‚ùå Rien √† exporter.","err"); return; }
    downloadJson(S.lastOutgoing.proof,`MWAL_POS_PROOF_${S.posId}_${S.lastOutgoing.proof.txId}.json`);
  });
  $("btnExportPackage").addEventListener("click",()=>{
    if(!S.lastOutgoing||!S.lastOutgoing.proof){ setStatus($("posStatus"),"‚ùå Rien √† exporter.","err"); return; }
    const pkg={protocol:PACKAGE_PROTOCOL,key:S.lastOutgoing.key,code:S.lastOutgoing.code,proof:S.lastOutgoing.proof,createdAt:new Date().toISOString()};
    downloadJson(pkg,`MWAL_POS_PACKAGE_${S.posId}_${S.lastOutgoing.proof.txId}.mwal.json`);
    setStatus($("posStatus"),"‚úÖ Paquet export√©.","ok");
  });
  $("btnExportChainDeposit").addEventListener("click",()=>{
    const raw=$("outChainDeposit").value.trim();
    if(!raw){ setStatus($("posStatus"),"‚ùå Rien √† exporter (d√©p√¥t blockchain).","err"); return; }
    try{
      const obj=JSON.parse(raw);
      downloadJson(obj,`MWAL_POS_CHAIN_DEPOSIT_${S.posId}_${(S.lastOutgoing&&S.lastOutgoing.proof&&S.lastOutgoing.proof.txId)||Date.now()}.json`);
      setStatus($("posStatus"),"‚úÖ D√©p√¥t blockchain export√©.","ok");
    }catch{
      setStatus($("posStatus"),"‚ùå D√©p√¥t blockchain invalide.","err");
    }
  });
  $("btnCopyChainDeposit").addEventListener("click",async ()=>{
    const ok=await copyText($("outChainDeposit").value);
    setStatus($("posStatus"), ok ? "üìã D√©p√¥t blockchain copi√©." : "‚ùå Copie impossible.","warn");
  });
  $("btnExportObserver").addEventListener("click",()=>{
    if(!S.lastOutgoing||!S.lastOutgoing.proof){ setStatus($("posStatus"),"‚ùå Rien √† exporter.","err"); return; }
    const obsPkg={
      protocol:"MWAL_OBSERVER_PACKAGE_V1",
      exportedAt:new Date().toISOString(),
      source:{ type:"POS", id:S.posId },
      package:{ protocol:PACKAGE_PROTOCOL, key:S.lastOutgoing.key, code:S.lastOutgoing.code, proof:S.lastOutgoing.proof, createdAt:new Date().toISOString() }
    };
    downloadJson(obsPkg,`MWAL_POS_OBS_${S.posId}_${S.lastOutgoing.proof.txId}.json`);
    setStatus($("posStatus"),"‚úÖ Export observation pr√™t.","ok");
  });

  // Ledger export/import
  $("btnExportLedger").addEventListener("click",()=>{ exportLedger().catch(e=>alert("‚ùå Export ledger: "+(e&&e.message?e.message:e))); });
  $("btnImportLedger").addEventListener("click",()=>{
    $("importLedger").value="";
    $("importLedger").click();
  });
  $("importLedger").addEventListener("change",(e)=>{
    const file=e.target.files&&e.target.files[0];
    if(file) importLedgerFile(file);
  });

  // Modal
  $("btnCloseLedgerModal").addEventListener("click",()=>showLedgerModal(false));
  $("btnLedgerCancel").addEventListener("click",()=>showLedgerModal(false));

  $("btnLedgerApply").addEventListener("click",async ()=>{
    try{
      if(!instanceHasLock){
        modalSetStatus("üîí Lecture seule : appliquer est bloqu√© (autre onglet actif).","warn");
        return;
      }
      if(!importedLedgerCtx || !importedLedgerCtx.parsed || !importedLedgerCtx.parsed.normalized){
        modalSetStatus("‚ùå Aucun ledger charg√©.","err");
        return;
      }
      const mode=getSelectedLedgerMode();
      const ledger=importedLedgerCtx.parsed.normalized;
      const ver=importedLedgerCtx.parsed.verify;

      if(ledger.protocol===LEDGER_PROTOCOL_V5){
        if(ver.hashOk !== true){
          modalSetStatus("‚ùå Hash du ledger invalide.","err");
          return;
        }
        if(ver.sigAsymOk !== true){
          modalSetStatus("‚ùå Signature ECDSA invalide : import bloqu√©.","err");
          return;
        }
        if(LEDGER_SAFE_MODE && mode!=="readonly"){
          const localKeyId = $("sigKeyId").value;
          const ledgerKeyId = ledger.signer && ledger.signer.keyId;
          if(!ledgerKeyId || ledgerKeyId !== localKeyId){
            modalSetStatus(
              "üîê Mode coffre-fort actif :\n" +
              "ce ledger n‚Äôa PAS √©t√© sign√© par cette caisse.\n" +
              "Restauration et fusion interdites.",
              "err"
            );
            return;
          }
        }
      }else{
        if(mode!=="readonly"){
          modalSetStatus("‚ö†Ô∏è Ledger ancien (V3) : pas de signature ECDSA.","warn");
          if(!confirm("Ledger V3 : continuer quand m√™me ?")) return;
        }
      }

      if(mode==="readonly"){
        modalSetStatus("üëÅÔ∏è Lecture seule : aucun changement appliqu√©.","ok");
        log("üëÅÔ∏è LEDGER READONLY pos="+ledger.posId+" tx="+ledger.accepted.length);
        return;
      }

      if(mode==="restore"){
        if(!confirm("Restaurer va √âCRASER la caisse locale. Continuer ?")) return;
        applyLedgerRestore(ledger);
        modalSetStatus("‚úÖ Restaur√©. Red√©marrage‚Ä¶","ok");
        log("‚úÖ LEDGER RESTORE pos="+ledger.posId);
        setTimeout(()=>location.reload(), 200);
        return;
      }

      if(mode==="merge"){
        const res = applyLedgerMerge(ledger);
        renderHeader(); renderStats(); renderHist();
        modalSetStatus(`‚úÖ Fusion OK : +${res.addedCount} TX ( +${res.addedAmount.toFixed(8)} MWAL )`,"ok");
        log(`üß† LEDGER MERGE +${res.addedCount} +${res.addedAmount.toFixed(8)}MWAL fromLedgerPos=${ledger.posId}`);
        return;
      }

    }catch(e){
      modalSetStatus("‚ùå Erreur: "+(e&&e.message?e.message:String(e)),"err");
    }
  });

  $("btnResetAll").addEventListener("click",resetAll);

  // Signing identity UI
  $("btnExportPubKey").addEventListener("click", async ()=>{
    try{
      const jwk = await exportPublicJwk();
      const keyId = await computeKeyIdFromJwk(jwk);
      downloadJson({protocol:"MWAL_PUBKEY_V1", alg:"ECDSA_P256_SHA256", keyId, pubJwk:jwk, exportedAt:new Date().toISOString()}, `MWAL_PUBKEY_${keyId.slice(0,12)}.json`);
      setStatus($("sysStatus"),"‚úÖ Cl√© publique export√©e.","ok");
      log("üîì PUBKEY EXPORT keyId="+keyId.slice(0,12));
    }catch(e){
      setStatus($("sysStatus"),"‚ùå Export pubkey : "+(e&&e.message?e.message:String(e)),"err");
    }
  });

  $("btnRotateKeys").addEventListener("click", async ()=>{
    if(!instanceHasLock){
      setStatus($("sysStatus"),"üîí Lecture seule : rotation bloqu√©e (autre onglet actif).","warn");
      return;
    }
    if(!confirm("Rotation cl√©s = tu casses la continuit√© de signature. Continuer ?")) return;
    if(!confirm("Dernier avertissement : anciens ledgers V5 ne seront plus restaurables en coffre-fort. Continuer ?")) return;
    await idbDel(SIGN_KEYPAIR_ID);
    const kp = await getOrCreateSigningKeyPair();
    const jwk = await crypto.subtle.exportKey("jwk", kp.publicKey);
    const keyId = await computeKeyIdFromJwk(jwk);
    $("sigKeyId").value = keyId;
    setStatus($("sysStatus"),"‚ö†Ô∏è Rotation effectu√©e (nouvelle identit√©).","warn");
    log("üîÅ KEY ROTATE newKeyId="+keyId.slice(0,12));
  });
}

/* ===================== Init signature identity ===================== */
async function initSigningIdentity(){
  const kp = await getOrCreateSigningKeyPair();
  const jwk = await crypto.subtle.exportKey("jwk", kp.publicKey);
  const keyId = await computeKeyIdFromJwk(jwk);
  $("sigKeyId").value = keyId;
  log("üîê SIGN ID ready keyId="+keyId.slice(0,12));
}

/* ===================== Init ===================== */
load();
renderHeader();
renderStats();
renderHist();
wire();
updateOutInfo();

/* ===== Acquire lock AFTER UI is ready ===== */
instanceHasLock = acquireInstanceLock();
if(instanceHasLock){
  startInstanceHeartbeat();
  log("üîí Instance lock ACQUIS id="+INSTANCE_ID);
}else{
  log("üö´ Instance lock REFUS√â (autre onglet actif)");
  startReclaimLoop();
}
enforceInstanceLockUI();

/* ===== React to other tabs ===== */
window.addEventListener("storage", (e)=>{
  if(e.key !== INSTANCE_LOCK_KEY) return;
  const now = Date.now();
  const lock = _readLock();
  if(lock && lock.id !== INSTANCE_ID && (now - lock.ts) < INSTANCE_LOCK_TTL){
    if(instanceHasLock){
      instanceHasLock = false;
      stopInstanceHeartbeat();
      log("üö´ Instance lock PERDU (autre onglet actif)");
      enforceInstanceLockUI();
    }
  }else{
    const ok = acquireInstanceLock();
    if(ok && !instanceHasLock){
      instanceHasLock = true;
      startInstanceHeartbeat();
      log("üîí Instance lock ACQUIS (storage) id="+INSTANCE_ID);
      enforceInstanceLockUI();
    }
  }
});

/* ===== Release on exit ===== */
window.addEventListener("beforeunload", ()=>{
  releaseInstanceLock();
  stopInstanceHeartbeat();
});

/* ===== Init signature ===== */
initSigningIdentity().then(()=>{
  if(instanceHasLock){
    setStatus($("sysStatus"),"‚úÖ Caisse pr√™te. (Coffre-fort ON + verrou anti-onglets ON)","ok");
  }else{
    // message d√©j√† mis par enforceInstanceLockUI()
    setStatus($("sysStatus"),
      "üîí Une autre instance de la caisse est active.\nCette instance est en lecture seule (anti-duplication d‚Äôonglets).",
      "warn"
    );
  }
  log("‚úÖ Caisse OFFLINE charg√©e id="+S.posId);
}).catch(e=>{
  setStatus($("sysStatus"),"‚ùå Signature init : "+(e&&e.message?e.message:String(e)),"err");
  log("‚ùå SIGN INIT failed");
});
})();
</script>
</body>
</html>
</template>
  <template id="bcTpl"><!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MWAL ‚Äî Blockchain OFFLINE (Manuel JSON ‚Ä¢ Mining ‚Ä¢ Blocs ‚Ä¢ Sorties)</title>
  <!-- GUN (diffusion publique du cours uniquement) -->
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/axe.js"></script>

  <style>
    :root{
      --bg:#070b16; --card:#0f1730; --text:#e9eeff; --muted:rgba(233,238,255,.72);
      --border:rgba(255,255,255,.14); --shadow:0 18px 60px rgba(0,0,0,.45);
      --up:#62f6b5; --down:#ff6b6b; --warn:#ffd34d; --cyan:#6ee7ff;
      --r:20px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background:
        radial-gradient(1100px 900px at 10% -20%, rgba(110,231,255,.18), transparent 55%),
        radial-gradient(900px 800px at 90% 0%, rgba(98,246,181,.14), transparent 60%),
        var(--bg);
      color:var(--text);
    }
    header{max-width:1280px;margin:0 auto;padding:22px 18px 10px}
    h1{margin:0 0 10px;font-size:22px;letter-spacing:.2px}
    .sub{margin:0;color:var(--muted);font-size:13px;line-height:1.45}
    main{max-width:1280px;margin:0 auto;padding:12px 18px 44px}
    .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:14px}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
      border:1px solid var(--border);border-radius:var(--r);box-shadow:var(--shadow);padding:14px}
    .card h2{margin:0 0 10px;font-size:14px}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border-radius:999px;
      border:1px solid var(--border);background:rgba(0,0,0,.18);font-size:12px;color:rgba(233,238,255,.92)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .col{flex:1;min-width:240px}
    label{display:block;font-size:12px;color:rgba(233,238,255,.78);margin:0 0 6px}
    input,select,textarea{width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--border);
      background:rgba(0,0,0,.25);color:var(--text);outline:none}
    textarea{resize:vertical}
    input:focus,select:focus,textarea:focus{border-color:rgba(110,231,255,.65); box-shadow:0 0 0 3px rgba(110,231,255,.12)}
    button{padding:10px 12px;border-radius:12px;border:1px solid var(--border);
      background:rgba(110,231,255,.10);color:var(--text);cursor:pointer}
    button:hover{background:rgba(110,231,255,.16)}
    button.primary{background:rgba(98,246,181,.14)}
    button.primary:hover{background:rgba(98,246,181,.20)}
    button.danger{background:rgba(255,107,107,.14)}
    button.danger:hover{background:rgba(255,107,107,.20)}
    button.warn{background:rgba(255,211,77,.14)}
    button.warn:hover{background:rgba(255,211,77,.20)}
    button:disabled{opacity:.55;cursor:not-allowed}
    .btnbar{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{padding:10px 8px;border-bottom:1px solid var(--border);vertical-align:top}
    th{text-align:left;color:rgba(233,238,255,.80);font-weight:600}
    .right{text-align:right}
    .hash{max-width:360px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .tag{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid var(--border);
      background:rgba(0,0,0,.18);font-size:11px;color:rgba(233,238,255,.86)}
    canvas{width:100%;height:360px;display:block;border:1px solid var(--border);border-radius:14px;background:rgba(0,0,0,.14)}
    details summary{cursor:pointer;color:rgba(233,238,255,.88)}
    .tiny{font-size:11px;color:rgba(233,238,255,.72);line-height:1.5}
    .ok{border-color:rgba(98,246,181,.45)}
    .bad{border-color:rgba(255,107,107,.45)}
    .warnb{border-color:rgba(255,211,77,.45)}
    .split{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:980px){.split{grid-template-columns:1fr}}
    .kbd{padding:2px 6px;border-radius:8px;border:1px solid var(--border);background:rgba(0,0,0,.22);font-size:11px}
  </style>
</head>
<body>
<header>
  <h1>MWAL ‚Äî Blockchain OFFLINE (Copier/Coller JSON ‚Ä¢ Mining PoW ‚Ä¢ Blocs ‚Ä¢ Sorties)</h1>
  <p class="sub">
    Cette application est une <b>blockchain t√©moin</b> utilisable <b>sans Internet</b>.
    Elle fonctionne comme une ‚Äúsuper-caisse‚Äù : tu <b>importes</b> un d√©p√¥t JSON (copier/coller),
    tu <b>mines</b> le d√©p√¥t (preuve de travail), la blockchain cr√©e un <b>bloc</b>,
    puis elle g√©n√®re une <b>sortie JSON</b> √† renvoyer manuellement (copier/coller) √† la caisse ou au wallet destinataire.
  </p>
</header>

<main>
  <div class="row" style="margin-bottom:12px">
    <span class="pill">Mode: <b>100% OFFLINE ‚Ä¢ Manuel</b></span>
    <span class="pill">D√©cimales: <b>20 chiffres apr√®s virgule</b></span>
    <span class="pill">Stockage: <b>localStorage</b></span>
    <span class="pill">Protocole: <span class="mono">MWAL_CHAIN_DEPOSIT_V1</span> ‚Üí <span class="mono">MWAL_CHAIN_BLOCK_V1</span> ‚Üí <span class="mono">MWAL_CHAIN_OUTPUT_V1</span></span>
  </div>

  <div class="grid">
    <section class="card">
      <h2>1) R√©ception Blockchain (Importer un d√©p√¥t JSON)</h2>
      <p class="tiny">
        Colle ici un d√©p√¥t JSON provenant d'une <b>caisse</b> ou d'un <b>wallet</b>. Le d√©p√¥t doit contenir un
        <b>libell√© (bien/service) obligatoire</b>. Sans libell√©, la blockchain refuse (pas de valorisation).
      </p>

      <div class="split" style="margin-top:10px">
        <div>
          <label>D√©p√¥t JSON (copier/coller)</label>
          <textarea id="depositIn" rows="14" class="mono" placeholder='Colle ici: {"protocol":"MWAL_CHAIN_DEPOSIT_V1",...}'></textarea>
          <div class="btnbar">
            <button class="primary" id="btnImport">V√©rifier & Importer</button>
            <button id="btnExample">Coller un exemple</button>
            <button class="warn" id="btnClearIn">Effacer</button>
          </div>
        </div>

        <div>
          <label>R√©sultat de validation</label>
          <div id="validateBox" class="pill warnb" style="display:block;border-radius:14px;line-height:1.5">
            En attente d'un d√©p√¥t JSON‚Ä¶
          </div>

          <details style="margin-top:12px">
            <summary>Sch√©ma d'un d√©p√¥t accept√©</summary>
            <div class="tiny" style="margin-top:10px">
              <div class="pill">Wrapper (obligatoire)</div>
              <pre class="mono" style="white-space:pre-wrap;margin:8px 0 0;background:rgba(0,0,0,.25);padding:10px;border-radius:12px;border:1px solid var(--border)">{
  "protocol":"MWAL_CHAIN_DEPOSIT_V1",
  "depositId":"DEP-...",
  "origin":"CAISSE|WALLET",
  "receivedAt":1730000000000,
  "payload": { ... JSON original caisse/wallet ... }
}</pre>
              <div class="pill" style="margin-top:10px">R√®gles m√©tier (minimales)</div>
              <ul class="tiny" style="margin:8px 0 0">
                <li><b>Libell√© obligatoire</b> : trouv√© dans <span class="mono">payload.label</span> ou <span class="mono">payload.meta.label</span> ou <span class="mono">payload.proof.label</span>.</li>
                <li>Actif: MWAL ou MWOLLOWM (sinon MWAL par d√©faut).</li>
                <li>Montant: cha√Æne num√©rique, jusqu'√† 20 d√©cimales.</li>
                <li>Destinataire final: trouv√© dans <span class="mono">payload.finalTo</span> ou <span class="mono">payload.to</span> (ou chemins proof).</li>
              </ul>
            </div>
          </details>

          <details style="margin-top:12px">
            <summary>Pourquoi ‚Äú‚Ç¨‚Äù est demand√© au minage ?</summary>
            <div class="tiny" style="margin-top:10px">
              Ton syst√®me valorise par <b>biens & services</b>. Offline, l'op√©rateur (t√©moin) peut saisir
              le montant en euros associ√© au libell√© (ex: ‚Äúr√©paration v√©lo = 25‚Ç¨‚Äù).
              Le cours est alors: <span class="mono">rate = eur / amount</span>.
            </div>
          </details>
        </div>
      </div>

      <hr style="border:0;border-top:1px solid var(--border);margin:16px 0"/>

      <h2>2) File des d√©p√¥ts (en attente / trait√©s)</h2>
      <div class="row" style="margin-bottom:10px">
        <span class="pill">D√©p√¥ts en attente: <b id="pendingCount">0</b></span>
        <span class="pill">D√©p√¥ts trait√©s: <b id="doneCount">0</b></span>
        <span class="pill">S√©lection: <span class="mono" id="selDeposit">‚Äî</span></span>
      </div>

      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th>D√©p√¥t</th>
              <th>Origine</th>
              <th>Actif</th>
              <th class="right">Montant</th>
              <th>Libell√©</th>
              <th>Destinataire</th>
              <th>Statut</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="depBody"></tbody>
        </table>
      </div>

      <hr style="border:0;border-top:1px solid var(--border);margin:16px 0"/>

      <h2>3) Minage Blockchain (preuve de travail)</h2>
      <p class="tiny">
        Miner = transformer un d√©p√¥t en bloc. Une fois min√©, la blockchain g√©n√®re automatiquement une <b>sortie JSON</b> (√† envoyer manuellement).
        Les boutons de minage restent <b>manuels</b>. Le minage est ‚Äúslic√©‚Äù pour ne pas bloquer la page.
      </p>

      <div class="row">
        <div class="col">
          <label>Difficult√© (z√©ros en hex)</label>
          <input id="diff" type="number" min="1" max="8" value="4"/>
          <div class="tiny">Ex: 4 = hash commence par <span class="mono">0000</span>.</div>
        </div>
        <div class="col">
          <label>Tranche CPU (ms)</label>
          <input id="slice" type="number" min="20" max="500" value="80"/>
          <div class="tiny">Recommand√©: 60‚Äì120.</div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="col">
          <label>‚Ç¨ associ√© au libell√© (obligatoire pour valorisation)</label>
          <input id="eurInput" type="text" class="mono" placeholder="ex: 25.00000000000000000000"/>
          <div class="tiny">Vide/0 = bloc TRANSFER (sans cours). >0 = bloc EXCHANGE (avec cours).</div>
        </div>
        <div class="col">
          <label>Note t√©moin (optionnel)</label>
          <input id="witnessNote" type="text" placeholder="ex: facture, r√©f√©rence..."/>
        </div>
      </div>

      <div class="btnbar">
        <button class="primary" id="btnMine">‚õèÔ∏è Miner le d√©p√¥t s√©lectionn√©</button>
        <button class="danger" id="btnStop" disabled>Stop</button>
        <button class="warn" id="btnResetChain">R√©initialiser la blockchain (local)</button>
        <button id="btnExportAll">Exporter tout (backup JSON)</button>
      </div>

      <div class="row" style="margin-top:10px">
        <span class="pill">Hashrate: <b id="hr">0</b> H/s</span>
        <span class="pill">Nonce: <span class="mono" id="nonce">‚Äî</span></span>
        <span class="pill">Hash: <span class="mono hash" id="hash">‚Äî</span></span>
        <span class="pill">Bloc: <span class="mono" id="miningBlk">‚Äî</span></span>
      </div>

      <div id="mineStatus" class="pill warnb" style="display:block;border-radius:14px;line-height:1.5;margin-top:10px">
        En attente‚Ä¶
      </div>
    </section>

    <section class="card">
      <h2>Dashboard OFFLINE ‚Äî Cours (MWAL/MWOLLOWM en ‚Ç¨) + Blocs + Sorties</h2>

      <div class="row" style="margin-bottom:10px">
        <span class="pill">Actif:
          <select id="assetSel" style="padding:6px 10px;border-radius:999px">
            <option value="MWAL" selected>MWAL</option>
            <option value="MWOLLOWM">MWOLLOWM</option>
          </select>
        </span>
        <span class="pill">Cours actuel: <b id="curRate">‚Äî</b></span>
        <span class="pill">Publication: <b id="pubStatus">‚Äî</b></span>
        <span class="pill">Points: <b id="ptCount">0</b></span>
      </div>

      <canvas id="chart" width="1200" height="360"></canvas>

      <hr style="border:0;border-top:1px solid var(--border);margin:16px 0"/>

      <h2>4) Blocs</h2>
      <div style="overflow:auto;margin-top:10px">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Type</th>
              <th>Actif</th>
              <th class="right">Montant</th>
              <th class="right">‚Ç¨</th>
              <th class="right">Rate</th>
              <th>Hash</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="blkBody"></tbody>
        </table>
      </div>

      <hr style="border:0;border-top:1px solid var(--border);margin:16px 0"/>

      <h2>5) Sorties (JSON √† envoyer manuellement)</h2>

      <div style="overflow:auto;margin-top:10px">
        <table>
          <thead>
            <tr>
              <th>Out</th>
              <th>To</th>
              <th>Actif</th>
              <th class="right">Montant</th>
              <th>Ref bloc</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="outBody"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:12px;background:rgba(0,0,0,.12)">
        <h2 style="margin-bottom:8px">Export manuel (copier / fichier)</h2>
        <label>JSON s√©lectionn√© (sortie ou backup)</label>
        <textarea id="exportBox" rows="9" class="mono" placeholder="Clique ‚ÄúCopier sortie‚Äù ou ‚ÄúExporter tout‚Äù‚Ä¶"></textarea>
        <div class="btnbar">
          <button id="btnCopy">Copier</button>
          <button id="btnDownload">T√©l√©charger JSON</button>
          <button class="warn" id="btnClearExport">Effacer</button>
        </div>
        <div class="tiny">Astuce : <span class="kbd">Ctrl</span>+<span class="kbd">A</span>, <span class="kbd">Ctrl</span>+<span class="kbd">C</span>.</div>
      </div>
    </section>
  </div>
</main>

<script>
(() => {
  'use strict';

  // ============================================================
  // Diffusion publique (GUN) ‚Äî cours uniquement (lecture seule c√¥t√© public)
  // IMPORTANT: GUN ne sert PAS aux transactions.
  // Si hors-ligne, file d‚Äôattente localStorage et retry.
  // ============================================================
  const GUN_PEERS = ['https://gun-encaissement.onrender.com/gun'];
  const PUBLIC_NODE = 'MWAL_PUBLIC_COURSE_V1';
  const PUB_QUEUE_KEY = 'MWAL_PUB_QUEUE_V1';
  const pubQueue = loadJSON(PUB_QUEUE_KEY, []);
  let gun = null;
  try { if(window.Gun){ gun = Gun(GUN_PEERS); } } catch(e){ gun = null; }

  function setPubStatus(t){
    const el = document.getElementById('pubStatus');
    if(el) el.textContent = t || '‚Äî';
  }

  function enqueuePublicPoint(pt){
    pubQueue.push(pt);
    saveJSON(PUB_QUEUE_KEY, pubQueue);
  }

  function publishPublicPoint(pt){
    if(!gun){
      enqueuePublicPoint(pt);
      setPubStatus('queue (offline)');
      return false;
    }
    try{
      gun.get(PUBLIC_NODE).get(pt.asset).set(pt); // append-only
      setPubStatus('publi√©');
      return true;
    }catch(e){
      enqueuePublicPoint(pt);
      setPubStatus('queue (erreur)');
      return false;
    }
  }

  function retryPublishQueue(){
    if(!pubQueue.length) return;
    if(!gun) return;
    const batch = pubQueue.splice(0, 10);
    saveJSON(PUB_QUEUE_KEY, pubQueue);
    for(const pt of batch){
      try{ gun.get(PUBLIC_NODE).get(pt.asset).set(pt); }catch(e){ /* ignore */ }
    }
    setPubStatus(pubQueue.length ? ('queue '+pubQueue.length) : 'publi√©');
  }

  setInterval(retryPublishQueue, 6000);


  const KEY = {
    deposits: 'MWAL_OFFCHAIN_DEPOSITS_V1',
    blocks:   'MWAL_OFFCHAIN_BLOCKS_V1',
    outputs:  'MWAL_OFFCHAIN_OUTPUTS_V1',
    head:     'MWAL_OFFCHAIN_HEAD_V1',
    settings: 'MWAL_OFFCHAIN_SETTINGS_V1'
  };

  const $ = (id) => document.getElementById(id);

  function toStr20(v){
    const s = String(v ?? '').trim();
    if(!s) return '0';
    if(!s.includes('.')) return s;
    const parts = s.split('.');
    return parts[0] + '.' + (parts[1]||'').slice(0,20);
  }
  function isNumericString(s){
    if(typeof s !== 'string') return false;
    const t = s.trim();
    if(!t) return false;
    return /^-?\d+(\.\d+)?$/.test(t);
  }
  function safeNum(v){ const n=Number(v); return Number.isFinite(n)?n:0; }
  function normalizeAsset(a){
    const x = String(a||'').toUpperCase().trim();
    if(x.includes('MWOLLOW')) return 'MWOLLOWM';
    if(x.includes('MWAL')) return 'MWAL';
    return x || 'MWAL';
  }
  function uid(prefix){ return prefix+'-'+Date.now().toString(36).toUpperCase()+'-'+Math.random().toString(36).slice(2,8).toUpperCase(); }
  function escapeHtml(str){
    return String(str ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
      .replaceAll('"','&quot;').replaceAll("'","&#039;");
  }
  async function sha256Hex(text){
    const buf = new TextEncoder().encode(text);
    const hash = await crypto.subtle.digest('SHA-256', buf);
    return [...new Uint8Array(hash)].map(b=>b.toString(16).padStart(2,'0')).join('');
  }
  function powPrefix(d){ return '0'.repeat(Math.max(1, Math.min(8, d|0))); }

  function loadJSON(key, fallback){
    try{ const s=localStorage.getItem(key); if(!s) return fallback; return JSON.parse(s); }catch{ return fallback; }
  }
  function saveJSON(key, obj){ localStorage.setItem(key, JSON.stringify(obj)); }

  let deposits = loadJSON(KEY.deposits, []);
  let blocks   = loadJSON(KEY.blocks, []);
  let outputs  = loadJSON(KEY.outputs, []);
  let head     = loadJSON(KEY.head, { height:-1, hash:'0' });
  let settings = loadJSON(KEY.settings, { difficulty:4, slice:80 });

  function getDeep(obj, paths){
    for(const p of paths){
      const parts=p.split('.');
      let cur=obj, ok=true;
      for(const part of parts){
        if(cur && typeof cur==='object' && part in cur) cur=cur[part];
        else { ok=false; break; }
      }
      if(ok && cur!==undefined && cur!==null && String(cur).trim()!=='') return cur;
    }
    return '';
  }

  function extractPayloadInfo(wrapper){
    const payload = wrapper?.payload;
    if(!payload || typeof payload !== 'object') return null;

    const asset = normalizeAsset(getDeep(payload, ['asset','proof.asset','proof.unit','proof.token','meta.asset']));
    const amount = String(getDeep(payload, ['amount','proof.amount','meta.amount']) || '').trim();
    const label = String(getDeep(payload, ['label','meta.label','proof.label','meta.item','item','proof.item']) || '').trim();
    const finalTo = String(getDeep(payload, ['finalTo','to','proof.finalTo','proof.to','proof.toAddr','proof.toPOS']) || '').trim();
    const from = String(getDeep(payload, ['from','proof.from','proof.posId','proof.walletId','sender','meta.from']) || '').trim();
    return { payload, asset, amount, label, finalTo, from };
  }

  function validateDepositObject(obj){
    if(!obj || typeof obj !== 'object') return { ok:false, msg:'JSON invalide (objet attendu).' };
    if(obj.protocol !== 'MWAL_CHAIN_DEPOSIT_V1') return { ok:false, msg:'Protocol attendu: MWAL_CHAIN_DEPOSIT_V1.' };
    if(!obj.payload || typeof obj.payload !== 'object') return { ok:false, msg:'payload manquant.' };

    const info = extractPayloadInfo(obj);
    if(!info) return { ok:false, msg:'Impossible de lire payload.' };

    if(!info.label || info.label.trim().length < 2) return { ok:false, msg:'‚ùå Libell√© obligatoire (bien/service).' };
    if(!isNumericString(info.amount) || safeNum(info.amount) <= 0) return { ok:false, msg:'Montant invalide (>0).' };
    if(!info.finalTo || info.finalTo.trim().length < 3) return { ok:false, msg:'Destinataire final introuvable (payload.finalTo conseill√©).' };

    return { ok:true, msg:`‚úÖ OK ‚Äî actif ${info.asset}, montant ${toStr20(info.amount)}, libell√© ‚Äú${info.label}‚Äù.` };
  }

  function setValidate(msg, cls='warnb'){
    const box=$('validateBox');
    box.className='pill '+cls;
    box.textContent=msg;
  }

  let selectedDepositId = '';

  function setMineStatus(msg, cls='warnb'){
    const box=$('mineStatus');
    box.className='pill '+cls;
    box.textContent=msg;
  }

  function findDeposit(id){ return deposits.find(d=>d.depositId===id); }

  function setExport(text){ $('exportBox').value = text || ''; }

  $('btnCopy').addEventListener('click', async ()=>{
    const t=$('exportBox').value.trim();
    if(!t) return;
    await navigator.clipboard.writeText(t);
    alert('Copi√©.');
  });
  $('btnDownload').addEventListener('click', ()=>{
    const t=$('exportBox').value.trim();
    if(!t) return alert('Rien √† t√©l√©charger.');
    const blob=new Blob([t],{type:'application/json'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='mwal_export_'+Date.now()+'.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{URL.revokeObjectURL(a.href);a.remove();},0);
  });
  $('btnClearExport').addEventListener('click', ()=> setExport(''));

  function renderDeposits(){
    const tbody=$('depBody'); tbody.innerHTML='';
    const pending = deposits.filter(d=>d && d.status==='LOCKED' && !d.processed).length;
    const done = deposits.filter(d=>d && d.processed).length;
    $('pendingCount').textContent=String(pending);
    $('doneCount').textContent=String(done);
    $('selDeposit').textContent=selectedDepositId||'‚Äî';

    const list=[...deposits].sort((a,b)=>(b.receivedAt||0)-(a.receivedAt||0)).slice(0,80);
    for(const d of list){
      const info = extractPayloadInfo(d) || {};
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td class="mono hash" title="${escapeHtml(d.depositId)}">${escapeHtml(d.depositId||'')}</td>
        <td><span class="tag">${escapeHtml(d.origin||'‚Äî')}</span></td>
        <td class="mono">${escapeHtml(info.asset||'MWAL')}</td>
        <td class="right mono">${escapeHtml(toStr20(info.amount||''))}</td>
        <td title="${escapeHtml(info.label||'')}">${escapeHtml((info.label||'').slice(0,22))}${(info.label||'').length>22?'‚Ä¶':''}</td>
        <td class="mono hash" title="${escapeHtml(info.finalTo||'')}">${escapeHtml((info.finalTo||'').slice(0,16))}${(info.finalTo||'').length>16?'‚Ä¶':''}</td>
        <td>${d.processed ? '<span class="tag ok">PROCESSED</span>' : '<span class="tag warnb">LOCKED</span>'}</td>
        <td class="right"><button data-sel="${escapeHtml(d.depositId)}" class="${d.depositId===selectedDepositId?'primary':''}">S√©lectionner</button></td>
      `;
      tbody.appendChild(tr);
    }
    tbody.querySelectorAll('button[data-sel]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        selectedDepositId=btn.getAttribute('data-sel')||'';
        renderDeposits();
        setMineStatus('D√©p√¥t s√©lectionn√©: '+selectedDepositId,'warnb');
      });
    });

    renderBlocks(); renderOutputs(); refreshChart();
  }

  function renderBlocks(){
    const tbody=$('blkBody'); tbody.innerHTML='';
    const list=[...blocks].sort((a,b)=>(b.height||0)-(a.height||0)).slice(0,40);
    for(const b of list){
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td class="mono">${escapeHtml(b.height)}</td>
        <td><span class="tag">${escapeHtml(b.blockType||'')}</span></td>
        <td class="mono">${escapeHtml(b.asset||'')}</td>
        <td class="right mono">${escapeHtml(b.amount||'')}</td>
        <td class="right mono">${escapeHtml(b.eur||'')}</td>
        <td class="right mono">${Number(b.rate||0).toFixed(6)}</td>
        <td class="mono hash" title="${escapeHtml(b.hash||'')}">${escapeHtml((b.hash||'').slice(0,18))}‚Ä¶</td>
        <td class="right"><button data-bexp="${escapeHtml(b.hash||'')}">Copier bloc</button></td>
      `;
      tbody.appendChild(tr);
    }
    tbody.querySelectorAll('button[data-bexp]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const h=btn.getAttribute('data-bexp');
        const b=blocks.find(x=>x.hash===h);
        if(b) setExport(JSON.stringify(b,null,2));
      });
    });
  }

  function renderOutputs(){
    const tbody=$('outBody'); tbody.innerHTML='';
    const list=[...outputs].sort((a,b)=>(b.ts||0)-(a.ts||0)).slice(0,60);
    for(const o of list){
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td class="mono hash" title="${escapeHtml(o.outId)}">${escapeHtml(o.outId||'')}</td>
        <td class="mono hash" title="${escapeHtml(o.to)}">${escapeHtml((o.to||'').slice(0,18))}${(o.to||'').length>18?'‚Ä¶':''}</td>
        <td class="mono">${escapeHtml(o.asset||'')}</td>
        <td class="right mono">${escapeHtml(o.amount||'')}</td>
        <td class="mono hash" title="${escapeHtml(o.refBlock||'')}">${escapeHtml((o.refBlock||'').slice(0,18))}‚Ä¶</td>
        <td class="right"><button data-oexp="${escapeHtml(o.outId)}" class="primary">Copier sortie</button></td>
      `;
      tbody.appendChild(tr);
    }
    tbody.querySelectorAll('button[data-oexp]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id=btn.getAttribute('data-oexp');
        const o=outputs.find(x=>x.outId===id);
        if(o) setExport(JSON.stringify(o,null,2));
      });
    });
  }

  const canvas=$('chart');
  const ctx=canvas.getContext('2d');

  function buildSeries(asset){
    return blocks
      .filter(b=>b && b.blockType==='EXCHANGE' && normalizeAsset(b.asset)===asset && Number(b.rate)>0)
      .sort((a,b)=>(a.ts||0)-(b.ts||0))
      .map(b=>({ts:b.ts||0,v:Number(b.rate)}));
  }

  function refreshChart(){
    const asset=$('assetSel').value;
    const pts=buildSeries(asset);
    $('ptCount').textContent=String(pts.length);
    $('curRate').textContent=pts.length? (pts[pts.length-1].v.toFixed(6)+' ‚Ç¨') : '‚Äî';

    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(pts.length<2){
      ctx.fillStyle='rgba(233,238,255,.80)';
      ctx.font='16px system-ui';
      ctx.fillText('Aucun cours disponible (pas de blocs EXCHANGE).',18,40);
      ctx.font='12px system-ui';
      ctx.fillText('Mine un d√©p√¥t avec un ‚Ç¨ > 0 pour g√©n√©rer un bloc EXCHANGE.',18,62);
      return;
    }

    let minV=Infinity,maxV=-Infinity;
    for(const p of pts){ minV=Math.min(minV,p.v); maxV=Math.max(maxV,p.v); }
    if(minV===maxV){ minV*=0.99; maxV*=1.01; }

    const w=canvas.width,h=canvas.height;
    const left=40,right=18,top=18,bottom=32;
    const innerW=w-left-right, innerH=h-top-bottom;

    ctx.save(); ctx.globalAlpha=0.35; ctx.lineWidth=1;
    for(let i=0;i<=5;i++){
      const y=top+innerH*(i/5);
      ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(w-right,y); ctx.stroke();
    }
    ctx.restore();

    const t0=pts[0].ts, t1=pts[pts.length-1].ts, dt=Math.max(1,t1-t0);
    const xOf=t=>left+((t-t0)/dt)*innerW;
    const yOf=v=>top+(1-((v-minV)/(maxV-minV)))*innerH;

    const upColor=getComputedStyle(document.documentElement).getPropertyValue('--up').trim();
    const downColor=getComputedStyle(document.documentElement).getPropertyValue('--down').trim();

    for(let i=1;i<pts.length;i++){
      const a=pts[i-1], b=pts[i];
      ctx.strokeStyle=(b.v>=a.v)?upColor:downColor;
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(xOf(a.ts),yOf(a.v)); ctx.lineTo(xOf(b.ts),yOf(b.v)); ctx.stroke();
    }

    const last=pts[pts.length-1];
    ctx.fillStyle='rgba(233,238,255,.95)';
    ctx.beginPath(); ctx.arc(xOf(last.ts),yOf(last.v),4,0,Math.PI*2); ctx.fill();

    ctx.fillStyle='rgba(233,238,255,.80)';
    ctx.font='12px ui-monospace';
    ctx.fillText(minV.toFixed(6)+' ‚Ç¨',left,h-10);
    ctx.fillText(maxV.toFixed(6)+' ‚Ç¨',left,14);
  }
  $('assetSel').addEventListener('change', refreshChart);

  let mining={ running:false, targetId:'', nonce:0, hashes:0, lastTs:0, lastHash:'', candidate:null };

  function setMiningUI(){
    $('btnMine').disabled=mining.running;
    $('btnStop').disabled=!mining.running;
  }

  async function buildCandidateBlock(dep){
    const info=extractPayloadInfo(dep);
    if(!info) throw new Error('Payload illisible.');
    const diff=Number($('diff').value)||4;
    const eur=toStr20($('eurInput').value.trim()||'0');
    const amount=toStr20(info.amount);
    const isExchange=safeNum(eur)>0;
    const blockType=isExchange?'EXCHANGE':'TRANSFER';
    const rate=(isExchange && safeNum(amount)>0)?(safeNum(eur)/safeNum(amount)):0;

    const prev=head.hash||'0';
    const height=(head.height??-1)+1;

    const b={
      protocol:'MWAL_CHAIN_BLOCK_V1',
      height, prevHash:prev, ts:Date.now(),
      blockType, asset:info.asset,
      amount, eur:isExchange?eur:'0', rate,
      label:info.label, from:info.from||'', to:info.finalTo,
      pow:{ protocol:'MWAL_CHAIN_POW_V1', difficulty:diff, nonce:0, hash:'' },
      witness:{ protocol:'MWAL_WITNESS_V1', note:$('witnessNote').value.trim(), version:'OFFLINE' },
      refs:{ depositId:dep.depositId },
      payloadRef:{ protocol:'MWAL_PAYLOAD_REF_V1', depositId:dep.depositId }
    };

    const base=JSON.stringify({
      protocol:b.protocol,height:b.height,prevHash:b.prevHash,ts:b.ts,blockType:b.blockType,
      asset:b.asset,amount:b.amount,eur:b.eur,rate:b.rate,label:b.label,from:b.from,to:b.to,
      witness:b.witness,refs:b.refs,payloadRef:b.payloadRef,pow:{protocol:b.pow.protocol,difficulty:b.pow.difficulty}
    });

    return { block:b, base };
  }

  async function commitBlock(dep, block, pow){
    block.pow={...block.pow,...pow};
    block.hash=pow.hash.toUpperCase();

    blocks.push(block);
    head={ height:block.height, hash:block.hash, ts:block.ts };

    dep.processed=true;
    dep.processedAt=Date.now();
    dep.blockHash=block.hash;

    const out={
      protocol:'MWAL_CHAIN_OUTPUT_V1',
      outId:uid('OUT'),
      ts:Date.now(),
      to:block.to,
      asset:block.asset,
      amount:block.amount,
      refBlock:block.hash,
      status:'READY',
      label:block.label,
      refs:{ depositId:dep.depositId }
    };
    outputs.push(out);

    // Publier automatiquement le cours (uniquement pour EXCHANGE)
    if(block.blockType === 'EXCHANGE' && Number(block.rate) > 0){
      const point = {
        protocol: 'MWAL_PUBLIC_RATE_V1',
        asset: block.asset,
        rate: Number(block.rate),
        eur: block.eur,
        amount: block.amount,
        label: block.label,
        ts: block.ts,
        refBlock: block.hash
      };
      publishPublicPoint(point);
    }

    saveJSON(KEY.blocks,blocks);
    saveJSON(KEY.head,head);
    saveJSON(KEY.deposits,deposits);
    saveJSON(KEY.outputs,outputs);

    setMineStatus(`‚úÖ Bloc min√© (#${block.height}) + sortie cr√©√©e (${out.outId}).`,'ok');
    setExport(JSON.stringify(out,null,2));
    mining.candidate=null;
    mining.nonce=0;
    mining.hashes=0;
    $('miningBlk').textContent='‚Äî';
    setMiningUI();
    renderDeposits();
  }

  async function mineStep(){
    if(!mining.running) return;
    const dep=findDeposit(mining.targetId);
    if(!dep || dep.processed){
      mining.running=false;
      setMineStatus('Cible invalide (absent ou d√©j√† trait√©).','bad');
      setMiningUI();
      return;
    }

    const diff=Number($('diff').value)||4;
    const prefix=powPrefix(diff);
    const slice=Number($('slice').value)||80;

    if(!mining.candidate){
      try{
        mining.candidate=await buildCandidateBlock(dep);
        $('miningBlk').textContent=`#${mining.candidate.block.height} ${mining.candidate.block.blockType}`;
      }catch(e){
        mining.running=false;
        setMineStatus('Erreur: '+(e.message||'buildCandidate'),'bad');
        setMiningUI();
        return;
      }
    }

    const start=performance.now();
    let nonce=mining.nonce;
    let lastHash=mining.lastHash;

    while(performance.now()-start<slice){
      const h=await sha256Hex(mining.candidate.base+'|'+nonce);
      mining.hashes++;
      lastHash=h;
      if(h.startsWith(prefix)){
        $('nonce').textContent=String(nonce);
        $('hash').textContent=h.slice(0,18)+'‚Ä¶';
        mining.running=false;
        const pow={ protocol:'MWAL_CHAIN_POW_V1', difficulty:diff, nonce, hash:h };
        await commitBlock(dep, mining.candidate.block, pow);
        mining.lastHash='';
        $('hr').textContent='0';
        return;
      }
      nonce++;
    }

    mining.nonce=nonce;
    mining.lastHash=lastHash;
    $('nonce').textContent=String(nonce);
    $('hash').textContent=lastHash? (lastHash.slice(0,18)+'‚Ä¶'):'‚Äî';

    const now=performance.now();
    if(!mining.lastTs) mining.lastTs=now;
    const dt=now-mining.lastTs;
    if(dt>=700){
      const rate=Math.round(mining.hashes/(dt/1000));
      $('hr').textContent=String(rate);
      mining.lastTs=now;
      mining.hashes=0;
    }
  }

  function importDeposit(){
    const raw=$('depositIn').value.trim();
    if(!raw) return setValidate('Colle un d√©p√¥t JSON.','warnb');
    let obj;
    try{ obj=JSON.parse(raw); }catch{ return setValidate('JSON invalide (parse).','bad'); }

    if(!obj.depositId) obj.depositId=uid('DEP');
    if(!obj.origin) obj.origin='UNKNOWN';
    if(!obj.receivedAt) obj.receivedAt=Date.now();
    if(!obj.status) obj.status='LOCKED';

    const v=validateDepositObject(obj);
    if(!v.ok) return setValidate(v.msg,'bad');

    if(deposits.some(d=>d.depositId===obj.depositId)) return setValidate('D√©p√¥t d√©j√† pr√©sent (depositId duplicate).','warnb');

    deposits.push(obj);
    saveJSON(KEY.deposits,deposits);

    setValidate('Import r√©ussi: '+obj.depositId,'ok');
    selectedDepositId=obj.depositId;
    setMineStatus('Pr√™t √† miner: '+selectedDepositId,'warnb');
    renderDeposits();
  }

  function exportAll(){
    const backup={ protocol:'MWAL_OFFLINE_BACKUP_V1', ts:Date.now(), head, deposits, blocks, outputs };
    setExport(JSON.stringify(backup,null,2));
  }

  function resetAll(){
    if(!confirm('R√©initialiser d√©p√¥ts/blocs/sorties (localStorage) ?')) return;
    deposits=[]; blocks=[]; outputs=[]; head={height:-1,hash:'0'};
    selectedDepositId='';
    mining.running=false; mining.candidate=null; mining.nonce=0;
    saveJSON(KEY.deposits,deposits); saveJSON(KEY.blocks,blocks); saveJSON(KEY.outputs,outputs); saveJSON(KEY.head,head);
    $('depositIn').value='';
    setValidate('R√©initialis√©.','warnb');
    setMineStatus('R√©initialis√©.','warnb');
    $('nonce').textContent='‚Äî'; $('hash').textContent='‚Äî'; $('hr').textContent='0'; $('miningBlk').textContent='‚Äî';
    renderDeposits();
  }

  function pasteExample(){
    const example={
      protocol:'MWAL_CHAIN_DEPOSIT_V1',
      depositId:'DEP-DEMO-001',
      origin:'WALLET',
      receivedAt:Date.now(),
      status:'LOCKED',
      payload:{
        protocol:'MWAL_PACKAGE_V1',
        key:'MWAL|TX=DEMO|FROM=MWAL-WALLET-AAAA|TO=MWAL-CHAIN-CENTRAL|AMOUNT=1.25000000000000000000',
        code:'MWAL-AESGCM|IV|CIPHERTEXT',
        proof:{ protocol:'MWAL_MINING_V2', from:'MWAL-WALLET-AAAA', to:'MWAL-CHAIN-CENTRAL', amount:'1.25000000000000000000', asset:'MWAL' },
        asset:'MWAL',
        amount:'1.25000000000000000000',
        label:'r√©paration v√©lo',
        finalTo:'MWAL-POS-123456'
      }
    };
    $('depositIn').value=JSON.stringify(example,null,2);
    setValidate('Exemple coll√©. Clique ‚ÄúV√©rifier & Importer‚Äù.','warnb');
  }

  $('diff').value=settings.difficulty??4;
  $('slice').value=settings.slice??80;
  $('diff').addEventListener('change', ()=>{ settings.difficulty=Number($('diff').value)||4; saveJSON(KEY.settings,settings); });
  $('slice').addEventListener('change', ()=>{ settings.slice=Number($('slice').value)||80; saveJSON(KEY.settings,settings); });

  $('btnImport').addEventListener('click', importDeposit);
  $('btnExample').addEventListener('click', pasteExample);
  $('btnClearIn').addEventListener('click', ()=>{ $('depositIn').value=''; setValidate('Effac√©.','warnb'); });

  $('btnMine').addEventListener('click', ()=>{
    if(mining.running) return;
    if(!selectedDepositId) return setMineStatus('S√©lectionne un d√©p√¥t d‚Äôabord.','bad');
    const dep=findDeposit(selectedDepositId);
    if(!dep) return setMineStatus('D√©p√¥t introuvable.','bad');
    if(dep.processed) return setMineStatus('D√©p√¥t d√©j√† trait√©.','warnb');

    const eur=$('eurInput').value.trim();
    if(eur && (!isNumericString(eur) || safeNum(eur)<0)) return setMineStatus('‚Ç¨ invalide (nombre >=0).','bad');

    const info=extractPayloadInfo(dep);
    if(!info || !info.label || info.label.trim().length<2) return setMineStatus('Libell√© manquant: d√©p√¥t refus√©.','bad');

    mining.running=true;
    mining.targetId=selectedDepositId;
    mining.nonce=0; mining.hashes=0; mining.lastTs=0; mining.lastHash=''; mining.candidate=null;
    $('nonce').textContent='0'; $('hash').textContent='‚Äî'; $('hr').textContent='0';
    setMineStatus('Minage en cours‚Ä¶','warnb');
    setMiningUI();
  });

  $('btnStop').addEventListener('click', ()=>{
    mining.running=false;
    mining.candidate=null;
    setMineStatus('Minage stopp√©.','warnb');
    setMiningUI();
  });

  $('btnResetChain').addEventListener('click', resetAll);
  $('btnExportAll').addEventListener('click', exportAll);

  setInterval(()=>{ mineStep(); }, 60);

  if(head.height < 0 && blocks.length===0){
    const genesis={
      protocol:'MWAL_CHAIN_BLOCK_V1',
      height:0, prevHash:'0', ts:Date.now(),
      blockType:'GENESIS',
      asset:'', amount:'0', eur:'0', rate:0,
      label:'GENESIS', from:'', to:'',
      pow:{ protocol:'MWAL_CHAIN_POW_V1', difficulty:0, nonce:0, hash:'0' },
      witness:{ protocol:'MWAL_WITNESS_V1', note:'Init', version:'OFFLINE' },
      refs:{ depositId:'' },
      payloadRef:{ protocol:'MWAL_PAYLOAD_REF_V1', depositId:'' },
      hash:'GENESIS'
    };
    blocks.push(genesis);
    head={ height:0, hash:'GENESIS', ts:genesis.ts };
    saveJSON(KEY.blocks,blocks);
    saveJSON(KEY.head,head);
  }

  setPubStatus('‚Äî');
  setValidate('Pr√™t. Colle un d√©p√¥t JSON.','warnb');
  setMineStatus('Pr√™t. S√©lectionne un d√©p√¥t et mine.','warnb');
  renderDeposits();
  setMiningUI();
  refreshChart();

})();
</script>

<!--
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
DOCUMENTATION MWAL OFFLINE BLOCKCHAIN
-->
</body>
</html>
</template>
</main>

<script>
const $ = (id)=>document.getElementById(id);
const fmt8 = (n)=> (Number.isFinite(n) ? n.toFixed(8) : "‚Äî");

// Tabs
function activate(tabId, viewId){
  ["tDash","tWallet","tCaisse","tExpert"].forEach(id=>$(id).setAttribute("aria-selected", id===tabId ? "true":"false"));
  ["vDash","vWallet","vCaisse","vExpert"].forEach(id=>$(id).classList.toggle("active", id===viewId));
}
$("tDash").onclick = ()=>activate("tDash","vDash");
$("tWallet").onclick = ()=>{activate("tWallet","vWallet"); loadWallet();};
$("tCaisse").onclick = ()=>{activate("tCaisse","vCaisse"); loadCaisse();};
$("tExpert").onclick = ()=>{activate("tExpert","vExpert"); loadBC();};

let walletLoaded=false,caisseLoaded=false,bcLoaded=false;
function loadWallet(){ if(walletLoaded) return; $("walletFrame").srcdoc = $("walletTpl").innerHTML; walletLoaded=true; }
function loadCaisse(){ if(caisseLoaded) return; $("caisseFrame").srcdoc = $("caisseTpl").innerHTML; caisseLoaded=true; }
function loadBC(){ if(bcLoaded) return; $("bcFrame").srcdoc = $("bcTpl").innerHTML; bcLoaded=true; }

// Balances
function readWalletBalance(){
  try{ const s=localStorage.getItem("mwal_std_state"); if(!s) return null; const o=JSON.parse(s); const b=Number(o?.balance); return Number.isFinite(b)?b:0; }catch(e){ return null; }
}
function readCaisseBalance(){
  try{ const s=localStorage.getItem("mwal_pos_offline_v3"); if(!s) return null; const o=JSON.parse(s); const b=Number(o?.balance); return Number.isFinite(b)?b:0; }catch(e){ return null; }
}
function refreshBalances(){
  const wb=readWalletBalance(); const cb=readCaisseBalance();
  const ok=(wb!==null || cb!==null);
  const wv=(wb===null)?0:wb; const cv=(cb===null)?0:cb;
  $("tot").textContent = ok ? fmt8(wv+cv) : "‚Äî";
  $("tsLocal").textContent = new Date().toLocaleString("fr-FR");
  $("dotLocal").className = "dot" + (ok ? " ok":"");
  $("stLocal").textContent = ok ? "OK (local)" : "Aucune donn√©e (ouvre Wallet/Caisse)";
}

// Import to blockchain
function importToBlockchain(rawJson){
  if(!bcLoaded) loadBC();
  const frame = $("bcFrame");
  const doc = frame.contentWindow?.document;
  if(!doc) return;
  const depositIn = doc.getElementById("depositIn");
  const btnImport = doc.getElementById("btnImport");
  if(!depositIn || !btnImport) return;
  depositIn.value = rawJson;
  btnImport.click();

  if($("autoMine").checked){
    const eur = $("autoEur").value.trim();
    const eurInput = doc.getElementById("eurInput");
    const btnMine = doc.getElementById("btnMine");
    if(eurInput && btnMine){
      eurInput.value = eur;
      setTimeout(()=>btnMine.click(), 250);
    }
  }
}

// Bridge wallet -> blockchain
let seenWalletTx = new Set();
function bridgeWallet(){
  if(!$("autoBridge").checked) return;
  let hist;
  try{ hist = JSON.parse(localStorage.getItem("mwal_std_history")||"[]"); }catch(e){ return; }
  if(!Array.isArray(hist)) return;
  for(const tx of hist){
    const txId = tx.txId || tx.id;
    if(!txId || seenWalletTx.has(txId)) continue;
    seenWalletTx.add(txId);

    const amount = String(tx.amount ?? "0");
    const label = (tx.note && String(tx.note).trim()) ? String(tx.note).trim() : (tx.type==="POCT" ? "PoCT reward" : (tx.type||"WALLET TX"));
    const payload = {
      protocol:"MWAL_WALLET_TX_V1",
      asset:"MWAL",
      amount: amount,
      label: label,
      from: tx.fromId || "",
      to: tx.toId || "",
      meta: { type: tx.type||"", txId: txId, ts: tx.date ? new Date(tx.date).getTime() : Date.now() }
    };
    const dep = {
      protocol:"MWAL_CHAIN_DEPOSIT_V1",
      depositId:"DEP-WAL-"+txId,
      origin: (tx.type==="POCT") ? "POCT" : "WALLET",
      receivedAt: Date.now(),
      status:"LOCKED",
      payload: payload
    };
    importToBlockchain(JSON.stringify(dep, null, 2));
  }
}

// Bridge caisse -> blockchain
let lastCaisseDeposit = "";
function bridgeCaisse(){
  if(!$("autoBridge").checked) return;
  if(!caisseLoaded) return;
  const doc = $("caisseFrame").contentWindow?.document;
  if(!doc) return;
  const ta = doc.getElementById("outChainDeposit");
  if(!ta) return;
  const v = (ta.value||"").trim();
  if(!v) return;
  if(v === lastCaisseDeposit) return;
  lastCaisseDeposit = v;
  importToBlockchain(v);
}

// Public course via Gun (Render)
const DEFAULT_PEER = "https://gun-encaissement.onrender.com/gun";
$("peerLbl").textContent = DEFAULT_PEER;
let gun = null;
let pts = [];
function startGun(){
  try{ gun = Gun([DEFAULT_PEER]); $("dotGun").className="dot ok"; $("stGun").textContent="Gun connect√©"; }
  catch(e){ $("dotGun").className="dot"; $("stGun").textContent="Gun erreur"; gun=null; }
}
function subscribeCourse(){
  if(!gun) return;
  const NODE = "MWAL_PUBLIC_COURSE_V1";
  const seen = new Set();
  gun.get(NODE).get("MWAL").map().on((data, key)=>{
    if(!data || !data.ts || !data.rate) return;
    const id = data.refBlock || key || String(data.ts);
    if(seen.has(id)) return;
    seen.add(id);
    pts.push({ts:Number(data.ts)||0, rate:Number(data.rate)||0, refBlock:data.refBlock||"", label:data.label||""});
    pts.sort((a,b)=>a.ts-b.ts);
    if(pts.length>400) pts = pts.slice(-400);
    renderCourse();
  });
}
function renderCourse(){
  const last = pts.length ? pts[pts.length-1] : null;
  if(!last){ $("rateMWAL").textContent="‚Äî"; $("rateMWOLLOWM").textContent="‚Äî"; $("rateMeta").textContent="Aucun point de cours encore."; drawChart(); return; }
  const r = last.rate;
  $("rateMWAL").textContent = r.toFixed(6) + " ‚Ç¨";
  const rW = r * 144000;
  $("rateMWOLLOWM").textContent = rW.toFixed(2) + " ‚Ç¨";
  const ref = (last.refBlock||"").slice(0,16);
  $("rateMeta").textContent = "Dernier: " + new Date(last.ts).toLocaleString("fr-FR") + " ‚Ä¢ ref=" + ref + "‚Ä¶ ‚Ä¢ " + (last.label||"");
  drawChart();
}
function drawChart(){
  const canvas = $("chart");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(pts.length < 2){
    ctx.fillStyle="rgba(229,231,235,.8)";
    ctx.font="14px system-ui";
    ctx.fillText("Aucun graphique (pas assez de points).", 18, 34);
    return;
  }
  const w=canvas.width,h=canvas.height;
  const left=40,right=14,top=14,bottom=24;
  const innerW=w-left-right, innerH=h-top-bottom;
  let min=Infinity,max=-Infinity;
  for(const p of pts){ min=Math.min(min,p.rate); max=Math.max(max,p.rate); }
  if(min===max){ min*=0.99; max*=1.01; }
  const t0=pts[0].ts, t1=pts[pts.length-1].ts, dt=Math.max(1,t1-t0);
  const xOf=(t)=>left+((t-t0)/dt)*innerW;
  const yOf=(v)=>top+(1-((v-min)/(max-min)))*innerH;
  ctx.globalAlpha=.25; ctx.strokeStyle="rgba(255,255,255,.25)";
  for(let i=0;i<=4;i++){ const y=top+innerH*(i/4); ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(w-right,y); ctx.stroke(); }
  ctx.globalAlpha=1;
  ctx.lineWidth=2.5; ctx.strokeStyle="rgba(110,231,255,.9)";
  ctx.beginPath(); ctx.moveTo(xOf(pts[0].ts), yOf(pts[0].rate));
  for(let i=1;i<pts.length;i++) ctx.lineTo(xOf(pts[i].ts), yOf(pts[i].rate));
  ctx.stroke();
  const last=pts[pts.length-1];
  ctx.fillStyle="rgba(52,211,153,.95)";
  ctx.beginPath(); ctx.arc(xOf(last.ts), yOf(last.rate), 4, 0, Math.PI*2); ctx.fill();
}

// Buttons
$("btnOpenWallet").onclick = ()=>$("tWallet").click();
$("btnOpenCaisse").onclick = ()=>$("tCaisse").click();
$("btnRefresh").onclick = ()=>refreshBalances();

// Init
refreshBalances();
setInterval(refreshBalances, 1200);
startGun();
subscribeCourse();
setInterval(()=>{ try{ bridgeWallet(); bridgeCaisse(); }catch(e){} }, 1200);


/* ============================================================
   TOTAL UNIFIED ‚Äî PoW PAYMENT (cl√© + code + preuve JSON)
   - Compatible avec la Caisse (MWAL_MINING_V2 / MWAL_PACKAGE_V1)
   - Publie optionnellement sur Render GUN -> miner003_mined (V9 style)
   - D√©bite le TOTAL (wallet + caisse) au d√©marrage, et restaure si annulation
   ============================================================ */
(() => {
  "use strict";

  // ---- Protocol constants (align√©s mineur/caisse) ----
  const TOT_PROOF_PROTOCOL   = "MWAL_MINING_V2";
  const TOT_PAYLOAD_PROTOCOL = "MWAL_TX_PAYLOAD_V2";
  const TOT_PACKAGE_PROTOCOL = "MWAL_PACKAGE_V1";
  const TOT_UNIT_STR         = "0.00000694444444444444";
  const TOT_UNIT             = 0.00000694444444444444;
  const TOT_INTERVAL_MS      = 4000;
  const TOT_SECRET_DEFAULT   = "MWAL_CORE_2025_V2_PROTOCOL";

  // ---- GUN (Render) ----
  const TOT_GUN_PEER = "https://gun-encaissement.onrender.com/gun";
  const TOT_GUN_NODE = "miner003_mined";
  let totGun = null;
  let totGunNode = null;
  try{
    totGun = (window.Gun ? Gun([TOT_GUN_PEER]) : null);
    totGunNode = totGun ? totGun.get(TOT_GUN_NODE) : null;
  }catch(e){ /* ignore */ }

  // ---- Storage ----
  const TOT_STORE_KEY = "mwal_app_unique_total_miner_v1";

  // ---- UI helpers ----
  const $$ = (id) => document.getElementById(id);
  function setTotStatus(msg){ const el = $$("totStatus"); if(el) el.textContent = msg; }
  function round8(n){ return Math.round((Number(n)||0) * 1e8) / 1e8; }
  function nowIso(){ return new Date().toISOString(); }
  function uid(prefix="TX"){ return `${prefix}-${Date.now().toString(36).toUpperCase()}-${Math.random().toString(36).slice(2,8).toUpperCase()}`; }

  async function sha256Hex(text){
    const enc = new TextEncoder().encode(text);
    const buf = await crypto.subtle.digest("SHA-256", enc);
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
  }
  function b64FromBytes(bytes){
    let s=""; bytes.forEach(b=>s+=String.fromCharCode(b));
    return btoa(s);
  }
  async function deriveAesKey(secret){
    const base = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(secret),
      { name:"PBKDF2" },
      false,
      ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      { name:"PBKDF2", salt:new TextEncoder().encode("MWAL_SALT_V2"), iterations:100000, hash:"SHA-256" },
      base,
      { name:"AES-GCM", length:256 },
      false,
      ["encrypt","decrypt"]
    );
  }
  async function encryptJson(secret, obj){
    const key = await deriveAesKey(secret);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const plaintext = new TextEncoder().encode(JSON.stringify(obj));
    const ct = new Uint8Array(await crypto.subtle.encrypt({ name:"AES-GCM", iv }, key, plaintext));
    return "MWAL-AESGCM|" + b64FromBytes(iv) + "|" + b64FromBytes(ct);
  }

  // ---- Read balances from the unified app (already present functions) ----
  function readW(){ try{ const s=localStorage.getItem("mwal_std_state"); if(!s) return 0; const o=JSON.parse(s); return Number(o?.balance)||0; }catch(e){ return 0; } }
  function readC(){ try{ const s=localStorage.getItem("mwal_pos_offline_v3"); if(!s) return 0; const o=JSON.parse(s); return Number(o?.balance)||0; }catch(e){ return 0; } }
  function writeW(b){
    try{
      const s=localStorage.getItem("mwal_std_state"); const o=s?JSON.parse(s):{balance:0};
      o.balance = round8(b); localStorage.setItem("mwal_std_state", JSON.stringify(o));
    }catch(e){}
  }
  function writeC(b){
    try{
      const s=localStorage.getItem("mwal_pos_offline_v3"); const o=s?JSON.parse(s):{balance:0};
      o.balance = round8(b); localStorage.setItem("mwal_pos_offline_v3", JSON.stringify(o));
    }catch(e){}
  }

  function computeTargetBlocks(amountMWAL){
    if(!(amountMWAL>0)) return 0;
    const exact = amountMWAL / TOT_UNIT;
    const n = Math.round(exact);
    const ok = Math.abs(exact - n) < 1e-9;
    return ok ? n : 0;
  }

  function getPublisherId(){
    // priorit√©: caisse (POS id) sinon wallet id, sinon fallback stable
    try{
      const posId = localStorage.getItem("mwal_pos_id_v3");
      if(posId && typeof posId==="string") return posId;
    }catch(e){}
    try{
      const wal = localStorage.getItem("mwal_std_wallet_id");
      if(wal && typeof wal==="string") return wal;
    }catch(e){}
    return "MWAL-APP-UNIQUE-TOTAL";
  }

  // ---- session state ----
  let S = null;
  function defaultState(){ return { session:null, lastExport:null }; }
  function load(){
    try{ const raw=localStorage.getItem(TOT_STORE_KEY); S = raw ? Object.assign(defaultState(), JSON.parse(raw)) : defaultState(); }
    catch(e){ S = defaultState(); }
    save();
  }
  function save(){ try{ localStorage.setItem(TOT_STORE_KEY, JSON.stringify(S)); }catch(e){} }

  function pushEvt(evt){
    if(!S.session) return;
    S.session.logs = S.session.logs || [];
    S.session.logs.push(Object.assign({ ts: nowIso() }, evt));
    save();
  }

  // ---- Mining core ----
  let timer = null;
  function clearTimer(){ if(timer){ clearTimeout(timer); timer=null; } }

  async function makeBlock(prevHash, index, tsIso, txId){
    const block = {
      index,
      timestamp: tsIso,
      walletId: S.session.publisherId,
      txId,
      amountMWAL: TOT_UNIT_STR,
      prevHash,
      nonce: crypto.getRandomValues(new Uint32Array(1))[0]
    };
    block.hash = await sha256Hex(JSON.stringify(block));
    return block;
  }

  function updateUi(){
    const m = S.session;
    const bar = $$("totProgBar");
    const txt = $$("totProgTxt");
    const bPause = $$("btnTotPause");
    const bResume = $$("btnTotResume");
    const bCancel = $$("btnTotCancel");
    if(!m){
      if(bar) bar.style.width="0%";
      if(txt) txt.textContent="0 / 0";
      if(bPause) bPause.disabled=true;
      if(bResume) bResume.disabled=true;
      if(bCancel) bCancel.disabled=true;
      return;
    }
    const pct = m.targetBlocks ? Math.min(100, (m.doneBlocks/m.targetBlocks)*100) : 0;
    if(bar) bar.style.width = pct.toFixed(1) + "%";
    if(txt) txt.textContent = `${m.doneBlocks} / ${m.targetBlocks}`;
    if(bPause) bPause.disabled = (m.status!=="RUNNING");
    if(bResume) bResume.disabled = (m.status!=="PAUSED");
    if(bCancel) bCancel.disabled = !(m.status==="RUNNING" || m.status==="PAUSED");
  }

  function downloadJson(obj, filename){
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }
  async function copyText(text){
    if(!text) return false;
    try{ await navigator.clipboard.writeText(text); return true; }catch{ return false; }
  }

  function refreshBlocksInfo(){
    const amt = Number(($$("totAmount")?.value||"0").replace(",", "."));
    const n = computeTargetBlocks(amt);
    $$("totBlocksLbl").textContent = String(n>0 ? n : 0);
    $$("totEtaLbl").textContent = String(n>0 ? (n*4)+"s" : "0s");
    $$("totUnitLbl").textContent = TOT_UNIT_STR;
  }

  function lockAndDebitTotal(amount){
    const wb = round8(readW());
    const cb = round8(readC());
    const total = round8(wb+cb);
    if(total + 1e-12 < amount) throw new Error("Solde TOTAL insuffisant.");
    const fromW = Math.min(wb, amount);
    const fromC = round8(amount - fromW);
    // debit now (lock)
    writeW(wb - fromW);
    writeC(cb - fromC);
    return { fromW, fromC, before:{wb,cb}, after:{wb:wb-fromW, cb:cb-fromC} };
  }

  function restoreDebit(lock){
    if(!lock) return;
    writeW(lock.before.wb);
    writeC(lock.before.cb);
  }

  async function tick(){
    const m = S.session;
    if(!m || m.status!=="RUNNING") return;
    const idx = m.doneBlocks;
    const prevHash = (idx===0) ? "GENESIS" : m.blocks[idx-1].hash;
    const canonTs = new Date(m.startTimeMs + idx*TOT_INTERVAL_MS).toISOString();
    const blk = await makeBlock(prevHash, idx, canonTs, m.txId);
    m.blocks.push(blk);
    m.doneBlocks += 1;
    pushEvt({ event:"BLOCK", index: blk.index, hash: blk.hash });
    save();
    updateUi();
    setTotStatus(`‚õèÔ∏è Bloc ${m.doneBlocks}/${m.targetBlocks} produit.`);
    if(m.doneBlocks >= m.targetBlocks){
      m.status="DONE";
      pushEvt({ event:"END", blocks: m.targetBlocks });
      save();
      clearTimer();
      await finalizePackage();
      updateUi();
      setTotStatus("‚úÖ PoW TOTAL termin√©. Cl√© + code + JSON pr√™ts.");
      return;
    }
    clearTimer();
    timer = setTimeout(()=>tick(), TOT_INTERVAL_MS);
  }

  async function finalizePackage(){
    const m = S.session;
    if(!m || m.status!=="DONE") return;

    const amountMWAL = round8(m.targetBlocks * TOT_UNIT);

    const key = [
      "MWAL",
      "TX="+m.txId,
      "FROM="+encodeURIComponent(m.from),
      "TO="+m.to,
      "AMOUNT="+amountMWAL.toFixed(8),
      "TS="+encodeURIComponent(m.createdAt),
      m.label ? ("LABEL="+encodeURIComponent(m.label)) : ""
    ].filter(Boolean).join("|");

    const proof = {
      protocol: TOT_PROOF_PROTOCOL,
      walletId: m.publisherId,
      txId: m.txId,
      rules: { unitMWAL: TOT_UNIT_STR, intervalMs: TOT_INTERVAL_MS },
      to: m.to,
      from: m.from,
      label: m.label || "",
      createdAt: m.createdAt,
      blocks: m.blocks,
      finalHash: m.blocks.length ? m.blocks[m.blocks.length-1].hash : "0",
      logs: m.logs || [],
      meta: {
        origin: "MWAL_APP_UNIQUE_TOTAL",
        split: m.split,
        gunPeer: TOT_GUN_PEER,
        gunNode: TOT_GUN_NODE,
        pubGun: !!m.pubGun
      }
    };

    const proofHash = await sha256Hex(JSON.stringify(proof));
    const codePayload = {
      protocol: TOT_PAYLOAD_PROTOCOL,
      txId: m.txId,
      from: m.from,
      to: m.to,
      amountMWAL: amountMWAL.toFixed(8),
      createdAt: m.createdAt,
      label: m.label || "",
      proofHash
    };

    const secret = TOT_SECRET_DEFAULT;
    const code = await encryptJson(secret, codePayload);

    const pkg = { protocol: TOT_PACKAGE_PROTOCOL, key, code, proof, proofHash };

    S.lastExport = { key, code, proof, package: pkg };
    save();

    $$("totOutKey").value = key;
    $$("totOutCode").value = code;
    $$("totOutJson").value = JSON.stringify(proof, null, 2);

    $$("btnTotCopyKey").disabled = false;
    $$("btnTotCopyCode").disabled = false;
    $$("btnTotCopyJson").disabled = false;
    $$("btnTotCopyPkg").disabled = false;
    $$("btnTotDlProof").disabled = false;
    $$("btnTotDlPkg").disabled = false;

    // --- Publish to GUN (Render) like mineur V9 ---
    if(m.pubGun && totGunNode && navigator.onLine){
      try{
        pushEvt({ event:"PUBLISH_BEGIN", gunNode: TOT_GUN_NODE });
        let cumulative = 0;
        for(let i=0;i<m.blocks.length;i++){
          cumulative += TOT_UNIT;
          totGunNode.set({
            wallet: m.publisherId,
            serial: i+1,
            value: TOT_UNIT,
            cumulative_balance: Number(cumulative.toFixed(16)),
            date: m.blocks[i].timestamp,
            txId: m.txId,
            proofHash,
            origin: "APP_UNIQUE_TOTAL"
          });
        }
        pushEvt({ event:"PUBLISH_OK", count: m.blocks.length });
      }catch(e){
        pushEvt({ event:"PUBLISH_FAIL", error: String(e && e.message ? e.message : e) });
      }
      save();
    }
  }

  function validateInputs(){
    const to = ($$("totTo")?.value||"").trim();
    const from = ($$("totFrom")?.value||"").trim() || "TOTAL_UNIFIED";
    const label = ($$("totLabel")?.value||"").trim();
    const amount = Number(($$("totAmount")?.value||"0").replace(",", "."));
    if(!/^MWAL-(POS|WALLET)-[A-Z0-9]{6,12}$/.test(to)) return {ok:false, err:"TO invalide. Ex: MWAL-POS-ABC12345 ou MWAL-WALLET-ABC12345"};
    if(!(amount>0)) return {ok:false, err:"Montant invalide."};
    if(!label) return {ok:false, err:"Libell√© obligatoire (bien/service)."};
    const n = computeTargetBlocks(amount);
    if(n<=0) return {ok:false, err:"Montant non multiple exact de l‚Äôunit√© (0.00000694444444444444)."};
    const total = round8(readW()+readC());
    if(amount > total + 1e-12) return {ok:false, err:"Solde TOTAL insuffisant."};
    return {ok:true, to, from, label, amount: round8(amount), blocks:n};
  }

  async function start(){
    if(S.session && (S.session.status==="RUNNING" || S.session.status==="PAUSED")){
      setTotStatus("‚ö†Ô∏è Une session TOTAL est d√©j√† en cours.");
      return;
    }
    const v = validateInputs();
    if(!v.ok){ setTotStatus("‚ùå " + v.err); return; }

    // debit total now (lock funds)
    let lock;
    try{ lock = lockAndDebitTotal(v.amount); }
    catch(e){ setTotStatus("‚ùå " + e.message); return; }

    const txId = uid("TX");
    const startMs = Date.now();
    const pubGun = !!($$("totPubGun")?.checked);

    S.session = {
      protocol: TOT_PROOF_PROTOCOL,
      txId,
      publisherId: getPublisherId(),
      rules: { unitMWAL: TOT_UNIT_STR, intervalMs: TOT_INTERVAL_MS },
      to: v.to,
      from: v.from,
      label: v.label,
      amountMWAL: v.amount,
      targetBlocks: v.blocks,
      doneBlocks: 0,
      blocks: [],
      logs: [],
      status: "RUNNING",
      createdAt: nowIso(),
      startTimeMs: startMs,
      pubGun,
      split: { wallet: round8(lock.fromW), caisse: round8(lock.fromC) },
      debitLock: lock
    };

    pushEvt({ event:"START", to:v.to, amountMWAL:v.amount, targetBlocks:v.blocks, pubGun, split: S.session.split });

    S.lastExport = null;
    save();

    // reset outputs
    $$("totOutKey").value = "";
    $$("totOutCode").value = "";
    $$("totOutJson").value = "";
    $$("btnTotCopyKey").disabled = true;
    $$("btnTotCopyCode").disabled = true;
    $$("btnTotCopyJson").disabled = true;
    $$("btnTotCopyPkg").disabled = true;
    $$("btnTotDlProof").disabled = true;
    $$("btnTotDlPkg").disabled = true;

    updateUi();
    setTotStatus(`‚õèÔ∏è Session TOTAL d√©marr√©e : ${v.blocks} bloc(s) ‚Üí ~${v.blocks*4}s.`);
    clearTimer();
    timer = setTimeout(()=>tick(), 20);
  }

  function pause(){
    if(!S.session || S.session.status!=="RUNNING") return;
    S.session.status = "PAUSED";
    pushEvt({ event:"PAUSE" });
    save();
    clearTimer();
    updateUi();
    setTotStatus("‚è∏ Session TOTAL en pause.");
  }
  function resume(){
    if(!S.session || S.session.status!=="PAUSED") return;
    S.session.status = "RUNNING";
    pushEvt({ event:"RESUME" });
    save();
    updateUi();
    setTotStatus("‚ñ∂ Session TOTAL reprise.");
    clearTimer();
    timer = setTimeout(()=>tick(), 20);
  }
  function cancel(){
    if(!S.session || (S.session.status!=="RUNNING" && S.session.status!=="PAUSED")) return;
    // restore locked debit
    try{ restoreDebit(S.session.debitLock); }catch(e){}
    pushEvt({ event:"CANCEL_RESTORE_BALANCES" });
    save();
    clearTimer();
    S.session = null;
    save();
    updateUi();
    setTotStatus("üßπ Annul√©. Soldes restaur√©s.");
    // refresh dashboard total display if available
    try{ refreshBalances(); }catch(e){}
  }

  function restore(){
    if(!S.session){
      updateUi();
      return;
    }
    if(S.session.status==="RUNNING"){
      // s√©curit√© : pause si reload
      S.session.status="PAUSED";
      pushEvt({ event:"AUTO_PAUSE_RELOAD" });
      save();
      setTotStatus("‚ö†Ô∏è Session TOTAL retrouv√©e ‚Üí mise en pause. Clique ‚ÄúReprendre‚Äù.");
    }else if(S.session.status==="DONE" && S.lastExport){
      $$("totOutKey").value = S.lastExport.key || "";
      $$("totOutCode").value = S.lastExport.code || "";
      $$("totOutJson").value = S.lastExport.proof ? JSON.stringify(S.lastExport.proof, null, 2) : "";
      $$("btnTotCopyKey").disabled = !S.lastExport.key;
      $$("btnTotCopyCode").disabled = !S.lastExport.code;
      $$("btnTotCopyJson").disabled = !S.lastExport.proof;
      $$("btnTotCopyPkg").disabled = !S.lastExport.package;
      $$("btnTotDlProof").disabled = !S.lastExport.proof;
      $$("btnTotDlPkg").disabled = !S.lastExport.package;
      setTotStatus("‚úÖ Derni√®re session TOTAL termin√©e. Sorties disponibles.");
    }
    updateUi();
  }

  function wire(){
    if(!$$("btnTotStart")) return; // si l‚ÄôUI n‚Äôest pas pr√©sente
    $$("totAmount").addEventListener("input", refreshBlocksInfo);
    $$("btnTotStart").addEventListener("click", start);
    $$("btnTotPause").addEventListener("click", pause);
    $$("btnTotResume").addEventListener("click", resume);
    $$("btnTotCancel").addEventListener("click", cancel);

    $$("btnTotCopyKey").addEventListener("click", async ()=>{
      const ok = await copyText($$("totOutKey").value);
      setTotStatus(ok ? "‚úÖ Cl√© copi√©e." : "‚ùå Impossible de copier la cl√©.");
    });
    $$("btnTotCopyCode").addEventListener("click", async ()=>{
      const ok = await copyText($$("totOutCode").value);
      setTotStatus(ok ? "‚úÖ Code copi√©." : "‚ùå Impossible de copier le code.");
    });
    $$("btnTotCopyJson").addEventListener("click", async ()=>{
      const ok = await copyText($$("totOutJson").value);
      setTotStatus(ok ? "‚úÖ JSON copi√©." : "‚ùå Impossible de copier le JSON.");
    });
    $$("btnTotCopyPkg").addEventListener("click", async ()=>{
      const pkg = (S && S.lastExport && S.lastExport.package) ? JSON.stringify(S.lastExport.package, null, 2) : "";
      const ok = await copyText(pkg);
      setTotStatus(ok ? "‚úÖ PACKAGE copi√©." : "‚ùå Impossible de copier le PACKAGE.");
    });
    $$("btnTotDlProof").addEventListener("click", ()=>{
      if(!S.lastExport || !S.lastExport.proof) return;
      downloadJson(S.lastExport.proof, `MWAL_TOTAL_PROOF_${(S.session?S.session.publisherId:getPublisherId())}_${S.lastExport.proof.txId}.json`);
    });
    $$("btnTotDlPkg").addEventListener("click", ()=>{
      if(!S.lastExport || !S.lastExport.package) return;
      downloadJson(S.lastExport.package, `MWAL_TOTAL_PACKAGE_${(S.session?S.session.publisherId:getPublisherId())}_${S.lastExport.proof.txId}.mwal.json`);
    });
  }

  // init
  load();
  wire();
  refreshBlocksInfo();
  restore();
})();

</script>
</body>
</html>
